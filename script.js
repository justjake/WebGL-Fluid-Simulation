/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./script.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./script.ts":
/*!*******************!*\
  !*** ./script.ts ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\nMIT License\n\nCopyright (c) 2017 Pavel Dobryakov\nTypescript fork (c) 2020 Jake Teton-Landis\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nfunction safeParseInt(x) {\n    return parseInt(x.toString());\n}\nfunction notNull(value, msg) {\n    if (value == null) {\n        throw new Error(msg || 'value unexpectedly null');\n    }\n    return value; // TODO\n}\nconst canvas = document.getElementsByTagName('canvas')[0];\nresizeCanvas();\nconst NamedColors = {\n    Black: { r: 0, g: 0, b: 0 },\n    Red: { r: 245, g: 0, b: 0 },\n    NotionMarketingBackground: { r: 255, g: 254, b: 252 },\n};\nfunction dup(val) {\n    return JSON.parse(JSON.stringify(val));\n}\nconst config = {\n    SIM_RESOLUTION: 512,\n    DYE_RESOLUTION: 1024,\n    CAPTURE_RESOLUTION: 512,\n    DENSITY_DISSIPATION: 1,\n    VELOCITY_DISSIPATION: 0.2,\n    PRESSURE: 0.8,\n    PRESSURE_ITERATIONS: 20,\n    CURL: 30,\n    SPLAT_RADIUS: 0.25,\n    SPLAT_FORCE: 6000,\n    SHADING: true,\n    SPLAT_COLOR: dup(NamedColors.Red),\n    RANDOM_COLOR: true,\n    COLORFUL: true,\n    COLOR_UPDATE_SPEED: 10,\n    PAUSED: false,\n    BACK_COLOR: dup(NamedColors.Black),\n    TRANSPARENT: false,\n    BLOOM: true,\n    BLOOM_ITERATIONS: 8,\n    BLOOM_RESOLUTION: 256,\n    BLOOM_INTENSITY: 0.8,\n    BLOOM_THRESHOLD: 0.6,\n    BLOOM_SOFT_KNEE: 0.7,\n    SUNRAYS: true,\n    SUNRAYS_RESOLUTION: 196,\n    SUNRAYS_WEIGHT: 1.0,\n};\nclass Pointer {\n    constructor() {\n        this.id = -1;\n        this.texcoordX = 0;\n        this.texcoordY = 0;\n        this.prevTexcoordX = 0;\n        this.prevTexcoordY = 0;\n        this.deltaX = 0;\n        this.deltaY = 0;\n        this.down = false;\n        this.moved = false;\n        this.color = { r: 0, g: 0, b: 0 };\n        this.colorUpdates = 0;\n    }\n}\nlet pointers = [];\nlet splatStack = [];\npointers.push(new Pointer());\nconst { gl, ext } = getWebGLContext(canvas);\nif (isMobile()) {\n    config.DYE_RESOLUTION = 512;\n}\nif (!ext.supportLinearFiltering) {\n    config.DYE_RESOLUTION = 512;\n    config.SHADING = false;\n    config.BLOOM = false;\n    config.SUNRAYS = false;\n}\nstartGUI();\nfunction getWebGLContext(canvas) {\n    const params = {\n        alpha: true,\n        depth: false,\n        stencil: false,\n        antialias: false,\n        preserveDrawingBuffer: false,\n    };\n    const gl2 = canvas.getContext('webgl2', params);\n    const gl = gl2 ||\n        canvas.getContext('webgl', params) ||\n        canvas.getContext('experimental-webgl', params);\n    const isWebGL2 = !!gl2;\n    let halfFloat = undefined;\n    let supportLinearFiltering;\n    if (isWebGL2) {\n        gl.getExtension('EXT_color_buffer_float');\n        supportLinearFiltering = gl.getExtension('OES_texture_float_linear');\n    }\n    else {\n        halfFloat = gl.getExtension('OES_texture_half_float');\n        supportLinearFiltering = gl.getExtension('OES_texture_half_float_linear');\n    }\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);\n    const halfFloatTexType = isWebGL2 ? gl.HALF_FLOAT : halfFloat.HALF_FLOAT_OES;\n    let formatRGBA;\n    let formatRG;\n    let formatR;\n    if (isWebGL2) {\n        formatRGBA = getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, halfFloatTexType);\n        formatRG = getSupportedFormat(gl, gl.RG16F, gl.RG, halfFloatTexType);\n        formatR = getSupportedFormat(gl, gl.R16F, gl.RED, halfFloatTexType);\n    }\n    else {\n        formatRGBA = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n        formatRG = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n        formatR = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n    }\n    // Assumes global Google Analytics, disabled.\n    //ga('send', 'event', isWebGL2 ? 'webgl2' : 'webgl', formatRGBA == null ? 'not supported' : 'supported');\n    return {\n        gl,\n        ext: {\n            formatRGBA,\n            formatRG,\n            formatR,\n            halfFloatTexType,\n            supportLinearFiltering,\n        },\n    };\n}\nfunction getSupportedFormat(gl, internalFormat, format, type) {\n    /** TODO: | null */\n    if (!supportRenderTextureFormat(gl, internalFormat, format, type)) {\n        switch (internalFormat) {\n            case gl.R16F:\n                return getSupportedFormat(gl, gl.RG16F, gl.RG, type);\n            case gl.RG16F:\n                return getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, type);\n            default:\n                return null; // TODO\n        }\n    }\n    return {\n        internalFormat,\n        format,\n    };\n}\nfunction supportRenderTextureFormat(gl, internalFormat, format, type) {\n    let texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 4, 4, 0, format, type, null);\n    let fbo = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n    return status == gl.FRAMEBUFFER_COMPLETE;\n}\nfunction startGUI() {\n    var gui = new dat.GUI({ width: 300 });\n    gui\n        .add(config, 'DYE_RESOLUTION', {\n        ultra: 2048,\n        high: 1024,\n        medium: 512,\n        low: 256,\n        'very low': 128,\n    })\n        .name('quality')\n        .onFinishChange(initFramebuffers);\n    gui\n        .add(config, 'SIM_RESOLUTION', { '32': 32, '64': 64, '128': 128, '256': 256, '512': 512 })\n        .name('sim resolution')\n        .onFinishChange(initFramebuffers);\n    gui.add(config, 'DENSITY_DISSIPATION', 0, 4.0).name('density diffusion');\n    gui.add(config, 'VELOCITY_DISSIPATION', 0, 4.0).name('velocity diffusion');\n    gui.add(config, 'PRESSURE', 0.0, 1.0).name('pressure');\n    gui\n        .add(config, 'CURL', 0, 50)\n        .name('vorticity')\n        .step(1);\n    gui.add(config, 'SPLAT_RADIUS', 0.01, 1.0).name('splat radius');\n    gui\n        .add(config, 'SHADING')\n        .name('shading')\n        .onFinishChange(updateKeywords);\n    gui.addColor(config, 'SPLAT_COLOR').name('Splat color');\n    gui.add(config, 'RANDOM_COLOR').name('Use random color');\n    gui.add(config, 'COLORFUL').name('Paint the rainbow');\n    gui\n        .add(config, 'PAUSED')\n        .name('paused')\n        .listen();\n    gui\n        .add({\n        fun: () => {\n            splatStack.push(safeParseInt(Math.random() * 20) + 5);\n        },\n    }, 'fun')\n        .name('Random splats');\n    let bloomFolder = gui.addFolder('Bloom');\n    bloomFolder\n        .add(config, 'BLOOM')\n        .name('enabled')\n        .onFinishChange(updateKeywords);\n    bloomFolder.add(config, 'BLOOM_INTENSITY', 0.1, 2.0).name('intensity');\n    bloomFolder.add(config, 'BLOOM_THRESHOLD', 0.0, 1.0).name('threshold');\n    let sunraysFolder = gui.addFolder('Sunrays');\n    sunraysFolder\n        .add(config, 'SUNRAYS')\n        .name('enabled')\n        .onFinishChange(updateKeywords);\n    sunraysFolder.add(config, 'SUNRAYS_WEIGHT', 0.3, 1.0).name('weight');\n    let captureFolder = gui.addFolder('Capture');\n    captureFolder.addColor(config, 'BACK_COLOR').name('background color');\n    captureFolder.add(config, 'TRANSPARENT').name('transparent');\n    captureFolder.add({ fun: captureScreenshot }, 'fun').name('take screenshot');\n    let github = gui\n        .add({\n        fun: () => {\n            window.open('https://github.com/justjake/WebGL-Fluid-Simulation');\n            //ga('send', 'event', 'link button', 'github');\n        },\n    }, 'fun')\n        .name('Typescript');\n    github.__li.className = 'cr function bigFont';\n    github.__li.style.borderLeft = '3px solid #8C8C8C';\n    let githubIcon = document.createElement('span');\n    github.domElement.parentElement.appendChild(githubIcon);\n    githubIcon.className = 'icon github';\n    let original = gui\n        .add({\n        fun: () => {\n            window.open('https://github.com/PavelDoGreat/WebGL-Fluid-Simulation');\n            //ga('send', 'event', 'link button', 'github');\n        },\n    }, 'fun')\n        .name('Original');\n    original.__li.className = 'cr function bigFont';\n    original.__li.style.borderLeft = '3px solid #8C8C8C';\n    let originalGithubIcon = document.createElement('span');\n    original.domElement.parentElement.appendChild(originalGithubIcon);\n    originalGithubIcon.className = 'icon github';\n    if (isMobile())\n        gui.close();\n}\nfunction isMobile() {\n    return /Mobi|Android/i.test(navigator.userAgent);\n}\nfunction captureScreenshot() {\n    let res = getResolution(config.CAPTURE_RESOLUTION);\n    let target = createFBO(res.width, res.height, ext.formatRGBA.internalFormat, ext.formatRGBA.format, ext.halfFloatTexType, gl.NEAREST);\n    render(target);\n    let texture = framebufferToTexture(target);\n    texture = normalizeTexture(texture, target.width, target.height);\n    let captureCanvas = textureToCanvas(texture, target.width, target.height);\n    let datauri = captureCanvas.toDataURL();\n    downloadURI('fluid.png', datauri);\n    URL.revokeObjectURL(datauri);\n}\nfunction framebufferToTexture(target) {\n    gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);\n    let length = target.width * target.height * 4;\n    let texture = new Float32Array(length);\n    gl.readPixels(0, 0, target.width, target.height, gl.RGBA, gl.FLOAT, texture);\n    return texture;\n}\nfunction normalizeTexture(texture, width, height) {\n    let result = new Uint8Array(texture.length);\n    let id = 0;\n    for (let i = height - 1; i >= 0; i--) {\n        for (let j = 0; j < width; j++) {\n            let nid = i * width * 4 + j * 4;\n            result[nid + 0] = clamp01(texture[id + 0]) * 255;\n            result[nid + 1] = clamp01(texture[id + 1]) * 255;\n            result[nid + 2] = clamp01(texture[id + 2]) * 255;\n            result[nid + 3] = clamp01(texture[id + 3]) * 255;\n            id += 4;\n        }\n    }\n    return result;\n}\nfunction clamp01(input) {\n    return Math.min(Math.max(input, 0), 1);\n}\nfunction textureToCanvas(texture, width, height) {\n    let captureCanvas = document.createElement('canvas');\n    let ctx = notNull(captureCanvas.getContext('2d'), 'canvas.getContext(2d)');\n    captureCanvas.width = width;\n    captureCanvas.height = height;\n    let imageData = ctx.createImageData(width, height);\n    imageData.data.set(texture);\n    ctx.putImageData(imageData, 0, 0);\n    return captureCanvas;\n}\nfunction downloadURI(filename, uri) {\n    let link = document.createElement('a');\n    link.download = filename;\n    link.href = uri;\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n}\nclass Material {\n    constructor(vertexShader, fragmentShaderSource) {\n        this.vertexShader = vertexShader;\n        this.fragmentShaderSource = fragmentShaderSource;\n        this.programs = [];\n        this.activeProgram = null;\n        this.uniforms = undefined;\n    }\n    setKeywords(keywords) {\n        let hash = 0;\n        for (let i = 0; i < keywords.length; i++)\n            hash += hashCode(keywords[i]);\n        let program = this.programs[hash];\n        if (program == null) {\n            let fragmentShader = compileShader(gl.FRAGMENT_SHADER, this.fragmentShaderSource, keywords);\n            program = createProgram(this.vertexShader, fragmentShader);\n            this.programs[hash] = program;\n        }\n        if (program == this.activeProgram)\n            return;\n        this.uniforms = getUniforms(program);\n        this.activeProgram = program;\n    }\n    bind() {\n        gl.useProgram(this.activeProgram);\n    }\n}\nclass Program {\n    constructor(vertexShader, fragmentShader) {\n        this.program = createProgram(vertexShader, fragmentShader);\n        this.uniforms = getUniforms(this.program);\n    }\n    bind() {\n        gl.useProgram(this.program);\n    }\n}\nfunction createProgram(vertexShader, fragmentShader) {\n    let program = notNull(gl.createProgram());\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS))\n        throw gl.getProgramInfoLog(program);\n    return program;\n}\nfunction getUniforms(program) {\n    let uniforms = []; // TODO switch to {} if possible\n    let uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n    for (let i = 0; i < uniformCount; i++) {\n        let uniformName = notNull(gl.getActiveUniform(program, i)).name;\n        uniforms[uniformName] = notNull(gl.getUniformLocation(program, uniformName));\n    }\n    return uniforms;\n}\nfunction compileShader(type, source, keywords) {\n    source = addKeywords(source, keywords);\n    const shader = gl.createShader(type);\n    if (!shader) {\n        throw new Error(`failed to create shader type ${type}`);\n    }\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))\n        throw gl.getShaderInfoLog(shader);\n    return shader;\n}\nfunction addKeywords(source, keywords) {\n    if (keywords == null)\n        return source;\n    let keywordsString = '';\n    keywords.forEach(keyword => {\n        keywordsString += '#define ' + keyword + '\\n';\n    });\n    return keywordsString + source;\n}\nconst baseVertexShader = compileShader(gl.VERTEX_SHADER, `\n    precision highp float;\n\n    attribute vec2 aPosition;\n    varying vec2 vUv;\n    varying vec2 vL;\n    varying vec2 vR;\n    varying vec2 vT;\n    varying vec2 vB;\n    uniform vec2 texelSize;\n\n    void main () {\n        vUv = aPosition * 0.5 + 0.5;\n        vL = vUv - vec2(texelSize.x, 0.0);\n        vR = vUv + vec2(texelSize.x, 0.0);\n        vT = vUv + vec2(0.0, texelSize.y);\n        vB = vUv - vec2(0.0, texelSize.y);\n        gl_Position = vec4(aPosition, 0.0, 1.0);\n    }\n`);\nconst blurVertexShader = compileShader(gl.VERTEX_SHADER, `\n    precision highp float;\n\n    attribute vec2 aPosition;\n    varying vec2 vUv;\n    varying vec2 vL;\n    varying vec2 vR;\n    uniform vec2 texelSize;\n\n    void main () {\n        vUv = aPosition * 0.5 + 0.5;\n        float offset = 1.33333333;\n        vL = vUv - texelSize * offset;\n        vR = vUv + texelSize * offset;\n        gl_Position = vec4(aPosition, 0.0, 1.0);\n    }\n`);\nconst blurShader = compileShader(gl.FRAGMENT_SHADER, `\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying vec2 vUv;\n    varying vec2 vL;\n    varying vec2 vR;\n    uniform sampler2D uTexture;\n\n    void main () {\n        vec4 sum = texture2D(uTexture, vUv) * 0.29411764;\n        sum += texture2D(uTexture, vL) * 0.35294117;\n        sum += texture2D(uTexture, vR) * 0.35294117;\n        gl_FragColor = sum;\n    }\n`);\nconst copyShader = compileShader(gl.FRAGMENT_SHADER, `\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying highp vec2 vUv;\n    uniform sampler2D uTexture;\n\n    void main () {\n        gl_FragColor = texture2D(uTexture, vUv);\n    }\n`);\nconst clearShader = compileShader(gl.FRAGMENT_SHADER, `\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying highp vec2 vUv;\n    uniform sampler2D uTexture;\n    uniform float value;\n\n    void main () {\n        gl_FragColor = value * texture2D(uTexture, vUv);\n    }\n`);\nconst colorShader = compileShader(gl.FRAGMENT_SHADER, `\n    precision mediump float;\n\n    uniform vec4 color;\n\n    void main () {\n        gl_FragColor = color;\n    }\n`);\nconst checkerboardShader = compileShader(gl.FRAGMENT_SHADER, `\n    precision highp float;\n    precision highp sampler2D;\n\n    varying vec2 vUv;\n    uniform sampler2D uTexture;\n    uniform float aspectRatio;\n\n    #define SCALE 25.0\n\n    void main () {\n        vec2 uv = floor(vUv * SCALE * vec2(aspectRatio, 1.0));\n        float v = mod(uv.x + uv.y, 2.0);\n        v = v * 0.1 + 0.8;\n        gl_FragColor = vec4(vec3(v), 1.0);\n    }\n`);\nconst displayShaderSource = `\n    precision highp float;\n    precision highp sampler2D;\n\n    varying vec2 vUv;\n    varying vec2 vL;\n    varying vec2 vR;\n    varying vec2 vT;\n    varying vec2 vB;\n    uniform sampler2D uTexture;\n    uniform sampler2D uBloom;\n    uniform sampler2D uSunrays;\n    uniform sampler2D uDithering;\n    uniform vec2 ditherScale;\n    uniform vec2 texelSize;\n\n    vec3 linearToGamma (vec3 color) {\n        color = max(color, vec3(0));\n        return max(1.055 * pow(color, vec3(0.416666667)) - 0.055, vec3(0));\n    }\n\n    void main () {\n        vec3 c = texture2D(uTexture, vUv).rgb;\n\n    #ifdef SHADING\n        vec3 lc = texture2D(uTexture, vL).rgb;\n        vec3 rc = texture2D(uTexture, vR).rgb;\n        vec3 tc = texture2D(uTexture, vT).rgb;\n        vec3 bc = texture2D(uTexture, vB).rgb;\n\n        float dx = length(rc) - length(lc);\n        float dy = length(tc) - length(bc);\n\n        vec3 n = normalize(vec3(dx, dy, length(texelSize)));\n        vec3 l = vec3(0.0, 0.0, 1.0);\n\n        float diffuse = clamp(dot(n, l) + 0.7, 0.7, 1.0);\n        c *= diffuse;\n    #endif\n\n    #ifdef BLOOM\n        vec3 bloom = texture2D(uBloom, vUv).rgb;\n    #endif\n\n    #ifdef SUNRAYS\n        float sunrays = texture2D(uSunrays, vUv).r;\n        c *= sunrays;\n    #ifdef BLOOM\n        bloom *= sunrays;\n    #endif\n    #endif\n\n    #ifdef BLOOM\n        float noise = texture2D(uDithering, vUv * ditherScale).r;\n        noise = noise * 2.0 - 1.0;\n        bloom += noise / 255.0;\n        bloom = linearToGamma(bloom);\n        c += bloom;\n    #endif\n\n        float a = max(c.r, max(c.g, c.b));\n        gl_FragColor = vec4(c, a);\n    }\n`;\nconst bloomPrefilterShader = compileShader(gl.FRAGMENT_SHADER, `\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying vec2 vUv;\n    uniform sampler2D uTexture;\n    uniform vec3 curve;\n    uniform float threshold;\n\n    void main () {\n        vec3 c = texture2D(uTexture, vUv).rgb;\n        float br = max(c.r, max(c.g, c.b));\n        float rq = clamp(br - curve.x, 0.0, curve.y);\n        rq = curve.z * rq * rq;\n        c *= max(rq, br - threshold) / max(br, 0.0001);\n        gl_FragColor = vec4(c, 0.0);\n    }\n`);\nconst bloomBlurShader = compileShader(gl.FRAGMENT_SHADER, `\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying vec2 vL;\n    varying vec2 vR;\n    varying vec2 vT;\n    varying vec2 vB;\n    uniform sampler2D uTexture;\n\n    void main () {\n        vec4 sum = vec4(0.0);\n        sum += texture2D(uTexture, vL);\n        sum += texture2D(uTexture, vR);\n        sum += texture2D(uTexture, vT);\n        sum += texture2D(uTexture, vB);\n        sum *= 0.25;\n        gl_FragColor = sum;\n    }\n`);\nconst bloomFinalShader = compileShader(gl.FRAGMENT_SHADER, `\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying vec2 vL;\n    varying vec2 vR;\n    varying vec2 vT;\n    varying vec2 vB;\n    uniform sampler2D uTexture;\n    uniform float intensity;\n\n    void main () {\n        vec4 sum = vec4(0.0);\n        sum += texture2D(uTexture, vL);\n        sum += texture2D(uTexture, vR);\n        sum += texture2D(uTexture, vT);\n        sum += texture2D(uTexture, vB);\n        sum *= 0.25;\n        gl_FragColor = sum * intensity;\n    }\n`);\nconst sunraysMaskShader = compileShader(gl.FRAGMENT_SHADER, `\n    precision highp float;\n    precision highp sampler2D;\n\n    varying vec2 vUv;\n    uniform sampler2D uTexture;\n\n    void main () {\n        vec4 c = texture2D(uTexture, vUv);\n        float br = max(c.r, max(c.g, c.b));\n        c.a = 1.0 - min(max(br * 20.0, 0.0), 0.8);\n        gl_FragColor = c;\n    }\n`);\nconst sunraysShader = compileShader(gl.FRAGMENT_SHADER, `\n    precision highp float;\n    precision highp sampler2D;\n\n    varying vec2 vUv;\n    uniform sampler2D uTexture;\n    uniform float weight;\n\n    #define ITERATIONS 16\n\n    void main () {\n        float Density = 0.3;\n        float Decay = 0.95;\n        float Exposure = 0.7;\n\n        vec2 coord = vUv;\n        vec2 dir = vUv - 0.5;\n\n        dir *= 1.0 / float(ITERATIONS) * Density;\n        float illuminationDecay = 1.0;\n\n        float color = texture2D(uTexture, vUv).a;\n\n        for (int i = 0; i < ITERATIONS; i++)\n        {\n            coord -= dir;\n            float col = texture2D(uTexture, coord).a;\n            color += col * illuminationDecay * weight;\n            illuminationDecay *= Decay;\n        }\n\n        gl_FragColor = vec4(color * Exposure, 0.0, 0.0, 1.0);\n    }\n`);\nconst splatShader = compileShader(gl.FRAGMENT_SHADER, `\n    precision highp float;\n    precision highp sampler2D;\n\n    varying vec2 vUv;\n    uniform sampler2D uTarget;\n    uniform float aspectRatio;\n    uniform vec3 color;\n    uniform vec2 point;\n    uniform float radius;\n\n    void main () {\n        vec2 p = vUv - point.xy;\n        p.x *= aspectRatio;\n        vec3 splat = exp(-dot(p, p) / radius) * color;\n        vec3 base = texture2D(uTarget, vUv).xyz;\n        gl_FragColor = vec4(base + splat, 1.0);\n    }\n`);\nconst advectionShader = compileShader(gl.FRAGMENT_SHADER, `\n    precision highp float;\n    precision highp sampler2D;\n\n    varying vec2 vUv;\n    uniform sampler2D uVelocity;\n    uniform sampler2D uSource;\n    uniform vec2 texelSize;\n    uniform vec2 dyeTexelSize;\n    uniform float dt;\n    uniform float dissipation;\n\n    vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {\n        vec2 st = uv / tsize - 0.5;\n\n        vec2 iuv = floor(st);\n        vec2 fuv = fract(st);\n\n        vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);\n        vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);\n        vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);\n        vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);\n\n        return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);\n    }\n\n    void main () {\n    #ifdef MANUAL_FILTERING\n        vec2 coord = vUv - dt * bilerp(uVelocity, vUv, texelSize).xy * texelSize;\n        vec4 result = bilerp(uSource, coord, dyeTexelSize);\n    #else\n        vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;\n        vec4 result = texture2D(uSource, coord);\n    #endif\n        float decay = 1.0 + dissipation * dt;\n        gl_FragColor = result / decay;\n    }`, ext.supportLinearFiltering ? undefined : ['MANUAL_FILTERING']);\nconst divergenceShader = compileShader(gl.FRAGMENT_SHADER, `\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying highp vec2 vUv;\n    varying highp vec2 vL;\n    varying highp vec2 vR;\n    varying highp vec2 vT;\n    varying highp vec2 vB;\n    uniform sampler2D uVelocity;\n\n    void main () {\n        float L = texture2D(uVelocity, vL).x;\n        float R = texture2D(uVelocity, vR).x;\n        float T = texture2D(uVelocity, vT).y;\n        float B = texture2D(uVelocity, vB).y;\n\n        vec2 C = texture2D(uVelocity, vUv).xy;\n        if (vL.x < 0.0) { L = -C.x; }\n        if (vR.x > 1.0) { R = -C.x; }\n        if (vT.y > 1.0) { T = -C.y; }\n        if (vB.y < 0.0) { B = -C.y; }\n\n        float div = 0.5 * (R - L + T - B);\n        gl_FragColor = vec4(div, 0.0, 0.0, 1.0);\n    }\n`);\nconst curlShader = compileShader(gl.FRAGMENT_SHADER, `\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying highp vec2 vUv;\n    varying highp vec2 vL;\n    varying highp vec2 vR;\n    varying highp vec2 vT;\n    varying highp vec2 vB;\n    uniform sampler2D uVelocity;\n\n    void main () {\n        float L = texture2D(uVelocity, vL).y;\n        float R = texture2D(uVelocity, vR).y;\n        float T = texture2D(uVelocity, vT).x;\n        float B = texture2D(uVelocity, vB).x;\n        float vorticity = R - L - T + B;\n        gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);\n    }\n`);\nconst vorticityShader = compileShader(gl.FRAGMENT_SHADER, `\n    precision highp float;\n    precision highp sampler2D;\n\n    varying vec2 vUv;\n    varying vec2 vL;\n    varying vec2 vR;\n    varying vec2 vT;\n    varying vec2 vB;\n    uniform sampler2D uVelocity;\n    uniform sampler2D uCurl;\n    uniform float curl;\n    uniform float dt;\n\n    void main () {\n        float L = texture2D(uCurl, vL).x;\n        float R = texture2D(uCurl, vR).x;\n        float T = texture2D(uCurl, vT).x;\n        float B = texture2D(uCurl, vB).x;\n        float C = texture2D(uCurl, vUv).x;\n\n        vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));\n        force /= length(force) + 0.0001;\n        force *= curl * C;\n        force.y *= -1.0;\n\n        vec2 vel = texture2D(uVelocity, vUv).xy;\n        gl_FragColor = vec4(vel + force * dt, 0.0, 1.0);\n    }\n`);\nconst pressureShader = compileShader(gl.FRAGMENT_SHADER, `\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying highp vec2 vUv;\n    varying highp vec2 vL;\n    varying highp vec2 vR;\n    varying highp vec2 vT;\n    varying highp vec2 vB;\n    uniform sampler2D uPressure;\n    uniform sampler2D uDivergence;\n\n    void main () {\n        float L = texture2D(uPressure, vL).x;\n        float R = texture2D(uPressure, vR).x;\n        float T = texture2D(uPressure, vT).x;\n        float B = texture2D(uPressure, vB).x;\n        float C = texture2D(uPressure, vUv).x;\n        float divergence = texture2D(uDivergence, vUv).x;\n        float pressure = (L + R + B + T - divergence) * 0.25;\n        gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\n    }\n`);\nconst gradientSubtractShader = compileShader(gl.FRAGMENT_SHADER, `\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying highp vec2 vUv;\n    varying highp vec2 vL;\n    varying highp vec2 vR;\n    varying highp vec2 vT;\n    varying highp vec2 vB;\n    uniform sampler2D uPressure;\n    uniform sampler2D uVelocity;\n\n    void main () {\n        float L = texture2D(uPressure, vL).x;\n        float R = texture2D(uPressure, vR).x;\n        float T = texture2D(uPressure, vT).x;\n        float B = texture2D(uPressure, vB).x;\n        vec2 velocity = texture2D(uVelocity, vUv).xy;\n        velocity.xy -= vec2(R - L, T - B);\n        gl_FragColor = vec4(velocity, 0.0, 1.0);\n    }\n`);\nconst blit = (() => {\n    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), gl.STATIC_DRAW);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), gl.STATIC_DRAW);\n    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(0);\n    return (destination) => {\n        gl.bindFramebuffer(gl.FRAMEBUFFER, destination);\n        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n    };\n})();\nlet dye;\nlet velocity;\nlet divergence;\nlet curl;\nlet pressure;\nlet bloom;\nlet bloomFramebuffers = [];\nlet sunrays;\nlet sunraysTemp;\nlet ditheringTexture = createTextureAsync('LDR_LLL1_0.png');\nconst blurProgram = new Program(blurVertexShader, blurShader);\nconst copyProgram = new Program(baseVertexShader, copyShader);\nconst clearProgram = new Program(baseVertexShader, clearShader);\nconst colorProgram = new Program(baseVertexShader, colorShader);\nconst checkerboardProgram = new Program(baseVertexShader, checkerboardShader);\nconst bloomPrefilterProgram = new Program(baseVertexShader, bloomPrefilterShader);\nconst bloomBlurProgram = new Program(baseVertexShader, bloomBlurShader);\nconst bloomFinalProgram = new Program(baseVertexShader, bloomFinalShader);\nconst sunraysMaskProgram = new Program(baseVertexShader, sunraysMaskShader);\nconst sunraysProgram = new Program(baseVertexShader, sunraysShader);\nconst splatProgram = new Program(baseVertexShader, splatShader);\nconst advectionProgram = new Program(baseVertexShader, advectionShader);\nconst divergenceProgram = new Program(baseVertexShader, divergenceShader);\nconst curlProgram = new Program(baseVertexShader, curlShader);\nconst vorticityProgram = new Program(baseVertexShader, vorticityShader);\nconst pressureProgram = new Program(baseVertexShader, pressureShader);\nconst gradienSubtractProgram = new Program(baseVertexShader, gradientSubtractShader);\nconst displayMaterial = new Material(baseVertexShader, displayShaderSource);\nfunction initFramebuffers() {\n    let simRes = getResolution(config.SIM_RESOLUTION);\n    let dyeRes = getResolution(config.DYE_RESOLUTION);\n    const texType = ext.halfFloatTexType;\n    const rgba = ext.formatRGBA;\n    const rg = ext.formatRG;\n    const r = ext.formatR;\n    const filtering = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;\n    if (dye == null)\n        dye = createDoubleFBO(dyeRes.width, dyeRes.height, rgba.internalFormat, rgba.format, texType, filtering);\n    else\n        dye = resizeDoubleFBO(dye, dyeRes.width, dyeRes.height, rgba.internalFormat, rgba.format, texType, filtering);\n    if (velocity == null)\n        velocity = createDoubleFBO(simRes.width, simRes.height, rg.internalFormat, rg.format, texType, filtering);\n    else\n        velocity = resizeDoubleFBO(velocity, simRes.width, simRes.height, rg.internalFormat, rg.format, texType, filtering);\n    divergence = createFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);\n    curl = createFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);\n    pressure = createDoubleFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);\n    initBloomFramebuffers();\n    initSunraysFramebuffers();\n}\nfunction initBloomFramebuffers() {\n    let res = getResolution(config.BLOOM_RESOLUTION);\n    const texType = ext.halfFloatTexType;\n    const rgba = ext.formatRGBA;\n    const filtering = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;\n    bloom = createFBO(res.width, res.height, rgba.internalFormat, rgba.format, texType, filtering);\n    bloomFramebuffers.length = 0;\n    for (let i = 0; i < config.BLOOM_ITERATIONS; i++) {\n        let width = res.width >> (i + 1);\n        let height = res.height >> (i + 1);\n        if (width < 2 || height < 2)\n            break;\n        let fbo = createFBO(width, height, rgba.internalFormat, rgba.format, texType, filtering);\n        bloomFramebuffers.push(fbo);\n    }\n}\nfunction initSunraysFramebuffers() {\n    let res = getResolution(config.SUNRAYS_RESOLUTION);\n    const texType = ext.halfFloatTexType;\n    const r = ext.formatR;\n    const filtering = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;\n    sunrays = createFBO(res.width, res.height, r.internalFormat, r.format, texType, filtering);\n    sunraysTemp = createFBO(res.width, res.height, r.internalFormat, r.format, texType, filtering);\n}\nfunction createFBO(w, h, internalFormat, format, type, param) {\n    gl.activeTexture(gl.TEXTURE0);\n    let texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, param);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, param);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);\n    let fbo = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    gl.viewport(0, 0, w, h);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    let texelSizeX = 1.0 / w;\n    let texelSizeY = 1.0 / h;\n    return {\n        texture,\n        fbo,\n        width: w,\n        height: h,\n        texelSizeX,\n        texelSizeY,\n        attach(id) {\n            gl.activeTexture(gl.TEXTURE0 + id);\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            return id;\n        },\n    };\n}\nfunction createDoubleFBO(w, h, internalFormat, format, type, param) {\n    let fbo1 = createFBO(w, h, internalFormat, format, type, param);\n    let fbo2 = createFBO(w, h, internalFormat, format, type, param);\n    return {\n        width: w,\n        height: h,\n        texelSizeX: fbo1.texelSizeX,\n        texelSizeY: fbo1.texelSizeY,\n        get read() {\n            return fbo1;\n        },\n        set read(value) {\n            fbo1 = value;\n        },\n        get write() {\n            return fbo2;\n        },\n        set write(value) {\n            fbo2 = value;\n        },\n        swap() {\n            let temp = fbo1;\n            fbo1 = fbo2;\n            fbo2 = temp;\n        },\n    };\n}\nfunction resizeFBO(target, w, h, internalFormat, format, type, param) {\n    let newFBO = createFBO(w, h, internalFormat, format, type, param);\n    copyProgram.bind();\n    gl.uniform1i(copyProgram.uniforms.uTexture, target.attach(0));\n    blit(newFBO.fbo);\n    return newFBO;\n}\nfunction resizeDoubleFBO(target, w, h, internalFormat, format, type, param) {\n    if (target.width == w && target.height == h)\n        return target;\n    target.read = resizeFBO(target.read, w, h, internalFormat, format, type, param);\n    target.write = createFBO(w, h, internalFormat, format, type, param);\n    target.width = w;\n    target.height = h;\n    target.texelSizeX = 1.0 / w;\n    target.texelSizeY = 1.0 / h;\n    return target;\n}\nfunction createTextureAsync(url) {\n    let texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 1, 1, 0, gl.RGB, gl.UNSIGNED_BYTE, new Uint8Array([255, 255, 255]));\n    let obj = {\n        texture,\n        width: 1,\n        height: 1,\n        attach(id) {\n            gl.activeTexture(gl.TEXTURE0 + id);\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            return id;\n        },\n    };\n    let image = new Image();\n    //image.crossOrigin = 'anonymous'\n    image.onload = () => {\n        obj.width = image.width;\n        obj.height = image.height;\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);\n    };\n    image.src = url;\n    return obj;\n}\nfunction updateKeywords() {\n    let displayKeywords = [];\n    if (config.SHADING)\n        displayKeywords.push('SHADING');\n    if (config.BLOOM)\n        displayKeywords.push('BLOOM');\n    if (config.SUNRAYS)\n        displayKeywords.push('SUNRAYS');\n    displayMaterial.setKeywords(displayKeywords);\n}\n// Main\nupdateKeywords();\ninitFramebuffers();\nmultipleSplats(safeParseInt(Math.random() * 20) + 5);\nlet lastUpdateTime = Date.now();\nlet colorUpdateTimer = 0.0;\nupdate();\nfunction update() {\n    const dt = calcDeltaTime();\n    if (resizeCanvas())\n        initFramebuffers();\n    updateColors(dt);\n    applyInputs();\n    if (!config.PAUSED)\n        step(dt);\n    render(null);\n    requestAnimationFrame(update);\n}\nfunction calcDeltaTime() {\n    let now = Date.now();\n    let dt = (now - lastUpdateTime) / 1000;\n    dt = Math.min(dt, 0.016666);\n    lastUpdateTime = now;\n    return dt;\n}\nfunction resizeCanvas() {\n    let width = scaleByPixelRatio(canvas.clientWidth);\n    let height = scaleByPixelRatio(canvas.clientHeight);\n    if (canvas.width != width || canvas.height != height) {\n        canvas.width = width;\n        canvas.height = height;\n        return true;\n    }\n    return false;\n}\nfunction updateColors(dt) {\n    if (!config.COLORFUL)\n        return;\n    colorUpdateTimer += dt * config.COLOR_UPDATE_SPEED;\n    if (colorUpdateTimer >= 1) {\n        colorUpdateTimer = wrap(colorUpdateTimer, 0, 1);\n        pointers.forEach(p => {\n            p.colorUpdates++;\n            if (p.colorUpdates > 2) {\n                p.color = generateColor();\n            }\n        });\n    }\n}\nfunction applyInputs() {\n    if (splatStack.length > 0)\n        multipleSplats(splatStack.pop() || 0);\n    pointers.forEach(p => {\n        if (p.moved) {\n            p.moved = false;\n            splatPointer(p);\n        }\n    });\n}\nfunction step(dt) {\n    gl.disable(gl.BLEND);\n    gl.viewport(0, 0, velocity.width, velocity.height);\n    curlProgram.bind();\n    gl.uniform2f(curlProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n    gl.uniform1i(curlProgram.uniforms.uVelocity, velocity.read.attach(0));\n    blit(curl.fbo);\n    vorticityProgram.bind();\n    gl.uniform2f(vorticityProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n    gl.uniform1i(vorticityProgram.uniforms.uVelocity, velocity.read.attach(0));\n    gl.uniform1i(vorticityProgram.uniforms.uCurl, curl.attach(1));\n    gl.uniform1f(vorticityProgram.uniforms.curl, config.CURL);\n    gl.uniform1f(vorticityProgram.uniforms.dt, dt);\n    blit(velocity.write.fbo);\n    velocity.swap();\n    divergenceProgram.bind();\n    gl.uniform2f(divergenceProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n    gl.uniform1i(divergenceProgram.uniforms.uVelocity, velocity.read.attach(0));\n    blit(divergence.fbo);\n    clearProgram.bind();\n    gl.uniform1i(clearProgram.uniforms.uTexture, pressure.read.attach(0));\n    gl.uniform1f(clearProgram.uniforms.value, config.PRESSURE);\n    blit(pressure.write.fbo);\n    pressure.swap();\n    pressureProgram.bind();\n    gl.uniform2f(pressureProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n    gl.uniform1i(pressureProgram.uniforms.uDivergence, divergence.attach(0));\n    for (let i = 0; i < config.PRESSURE_ITERATIONS; i++) {\n        gl.uniform1i(pressureProgram.uniforms.uPressure, pressure.read.attach(1));\n        blit(pressure.write.fbo);\n        pressure.swap();\n    }\n    gradienSubtractProgram.bind();\n    gl.uniform2f(gradienSubtractProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n    gl.uniform1i(gradienSubtractProgram.uniforms.uPressure, pressure.read.attach(0));\n    gl.uniform1i(gradienSubtractProgram.uniforms.uVelocity, velocity.read.attach(1));\n    blit(velocity.write.fbo);\n    velocity.swap();\n    advectionProgram.bind();\n    gl.uniform2f(advectionProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n    if (!ext.supportLinearFiltering)\n        gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, velocity.texelSizeX, velocity.texelSizeY);\n    let velocityId = velocity.read.attach(0);\n    gl.uniform1i(advectionProgram.uniforms.uVelocity, velocityId);\n    gl.uniform1i(advectionProgram.uniforms.uSource, velocityId);\n    gl.uniform1f(advectionProgram.uniforms.dt, dt);\n    gl.uniform1f(advectionProgram.uniforms.dissipation, config.VELOCITY_DISSIPATION);\n    blit(velocity.write.fbo);\n    velocity.swap();\n    gl.viewport(0, 0, dye.width, dye.height);\n    if (!ext.supportLinearFiltering)\n        gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, dye.texelSizeX, dye.texelSizeY);\n    gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.read.attach(0));\n    gl.uniform1i(advectionProgram.uniforms.uSource, dye.read.attach(1));\n    gl.uniform1f(advectionProgram.uniforms.dissipation, config.DENSITY_DISSIPATION);\n    blit(dye.write.fbo);\n    dye.swap();\n}\nfunction render(target) {\n    if (config.BLOOM)\n        applyBloom(dye.read, bloom);\n    if (config.SUNRAYS) {\n        applySunrays(dye.read, dye.write, sunrays);\n        blurFBO(sunrays, sunraysTemp, 1);\n    }\n    if (target == null || !config.TRANSPARENT) {\n        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n        gl.enable(gl.BLEND);\n    }\n    else {\n        gl.disable(gl.BLEND);\n    }\n    let width = target == null ? gl.drawingBufferWidth : target.width;\n    let height = target == null ? gl.drawingBufferHeight : target.height;\n    gl.viewport(0, 0, width, height);\n    let fbo = target == null ? null : target.fbo;\n    if (!config.TRANSPARENT)\n        drawColor(fbo, normalizeColor(config.BACK_COLOR));\n    if (target == null && config.TRANSPARENT)\n        drawCheckerboard(fbo);\n    drawDisplay(fbo, width, height);\n}\nfunction drawColor(fbo, color) {\n    colorProgram.bind();\n    gl.uniform4f(colorProgram.uniforms.color, color.r, color.g, color.b, 1);\n    blit(fbo);\n}\nfunction drawCheckerboard(fbo) {\n    checkerboardProgram.bind();\n    gl.uniform1f(checkerboardProgram.uniforms.aspectRatio, canvas.width / canvas.height);\n    blit(fbo);\n}\nfunction drawDisplay(fbo, width, height) {\n    displayMaterial.bind();\n    const uniforms = notNull(displayMaterial.uniforms);\n    if (config.SHADING)\n        gl.uniform2f(uniforms.texelSize, 1.0 / width, 1.0 / height);\n    gl.uniform1i(uniforms.uTexture, dye.read.attach(0));\n    if (config.BLOOM) {\n        gl.uniform1i(uniforms.uBloom, bloom.attach(1));\n        gl.uniform1i(uniforms.uDithering, ditheringTexture.attach(2));\n        let scale = getTextureScale(ditheringTexture, width, height);\n        gl.uniform2f(uniforms.ditherScale, scale.x, scale.y);\n    }\n    if (config.SUNRAYS)\n        gl.uniform1i(uniforms.uSunrays, sunrays.attach(3));\n    blit(fbo);\n}\nfunction applyBloom(source, destination) {\n    if (bloomFramebuffers.length < 2)\n        return;\n    let last = destination;\n    gl.disable(gl.BLEND);\n    bloomPrefilterProgram.bind();\n    let knee = config.BLOOM_THRESHOLD * config.BLOOM_SOFT_KNEE + 0.0001;\n    let curve0 = config.BLOOM_THRESHOLD - knee;\n    let curve1 = knee * 2;\n    let curve2 = 0.25 / knee;\n    gl.uniform3f(bloomPrefilterProgram.uniforms.curve, curve0, curve1, curve2);\n    gl.uniform1f(bloomPrefilterProgram.uniforms.threshold, config.BLOOM_THRESHOLD);\n    gl.uniform1i(bloomPrefilterProgram.uniforms.uTexture, source.attach(0));\n    gl.viewport(0, 0, last.width, last.height);\n    blit(last.fbo);\n    bloomBlurProgram.bind();\n    for (let i = 0; i < bloomFramebuffers.length; i++) {\n        let dest = bloomFramebuffers[i];\n        gl.uniform2f(bloomBlurProgram.uniforms.texelSize, last.texelSizeX, last.texelSizeY);\n        gl.uniform1i(bloomBlurProgram.uniforms.uTexture, last.attach(0));\n        gl.viewport(0, 0, dest.width, dest.height);\n        blit(dest.fbo);\n        last = dest;\n    }\n    gl.blendFunc(gl.ONE, gl.ONE);\n    gl.enable(gl.BLEND);\n    for (let i = bloomFramebuffers.length - 2; i >= 0; i--) {\n        let baseTex = bloomFramebuffers[i];\n        gl.uniform2f(bloomBlurProgram.uniforms.texelSize, last.texelSizeX, last.texelSizeY);\n        gl.uniform1i(bloomBlurProgram.uniforms.uTexture, last.attach(0));\n        gl.viewport(0, 0, baseTex.width, baseTex.height);\n        blit(baseTex.fbo);\n        last = baseTex;\n    }\n    gl.disable(gl.BLEND);\n    bloomFinalProgram.bind();\n    gl.uniform2f(bloomFinalProgram.uniforms.texelSize, last.texelSizeX, last.texelSizeY);\n    gl.uniform1i(bloomFinalProgram.uniforms.uTexture, last.attach(0));\n    gl.uniform1f(bloomFinalProgram.uniforms.intensity, config.BLOOM_INTENSITY);\n    gl.viewport(0, 0, destination.width, destination.height);\n    blit(destination.fbo);\n}\nfunction applySunrays(source, mask, destination) {\n    gl.disable(gl.BLEND);\n    sunraysMaskProgram.bind();\n    gl.uniform1i(sunraysMaskProgram.uniforms.uTexture, source.attach(0));\n    gl.viewport(0, 0, mask.width, mask.height);\n    blit(mask.fbo);\n    sunraysProgram.bind();\n    gl.uniform1f(sunraysProgram.uniforms.weight, config.SUNRAYS_WEIGHT);\n    gl.uniform1i(sunraysProgram.uniforms.uTexture, mask.attach(0));\n    gl.viewport(0, 0, destination.width, destination.height);\n    blit(destination.fbo);\n}\nfunction blurFBO(target, temp, iterations) {\n    blurProgram.bind();\n    for (let i = 0; i < iterations; i++) {\n        gl.uniform2f(blurProgram.uniforms.texelSize, target.texelSizeX, 0.0);\n        gl.uniform1i(blurProgram.uniforms.uTexture, target.attach(0));\n        blit(temp.fbo);\n        gl.uniform2f(blurProgram.uniforms.texelSize, 0.0, target.texelSizeY);\n        gl.uniform1i(blurProgram.uniforms.uTexture, temp.attach(0));\n        blit(target.fbo);\n    }\n}\nfunction splatPointer(pointer) {\n    let dx = pointer.deltaX * config.SPLAT_FORCE;\n    let dy = pointer.deltaY * config.SPLAT_FORCE;\n    splat(pointer.texcoordX, pointer.texcoordY, dx, dy, pointer.color);\n}\nfunction multipleSplats(amount) {\n    for (let i = 0; i < amount; i++) {\n        const color = generateColor();\n        color.r *= 10.0;\n        color.g *= 10.0;\n        color.b *= 10.0;\n        const x = Math.random();\n        const y = Math.random();\n        const dx = 1000 * (Math.random() - 0.5);\n        const dy = 1000 * (Math.random() - 0.5);\n        splat(x, y, dx, dy, color);\n    }\n}\n/**\n * Splat some dye into the simulation.\n * @param x Center X coordinate. Float from 0 (left) to 1 (right)\n * @param y Center Y coordinate. Float form 0 (bottom) to 1 (top)\n * @param dx Horizontal force vector element, in pixels. Positive -> left, negative -> right.\n * @param dy Vertical force vector element, in pixels. Positive -> top, negative -> bottom.\n * @param color Color. Using { r, g, b } values >1 creates a larger splat.\n */\nfunction splat(x, y, dx, dy, color, radius) {\n    gl.viewport(0, 0, velocity.width, velocity.height);\n    splatProgram.bind();\n    gl.uniform1i(splatProgram.uniforms.uTarget, velocity.read.attach(0));\n    gl.uniform1f(splatProgram.uniforms.aspectRatio, canvas.width / canvas.height);\n    gl.uniform2f(splatProgram.uniforms.point, x, y);\n    gl.uniform3f(splatProgram.uniforms.color, dx, dy, 0.0);\n    gl.uniform1f(splatProgram.uniforms.radius, correctRadius((radius || config.SPLAT_RADIUS) / 100.0));\n    blit(velocity.write.fbo);\n    velocity.swap();\n    if (color) {\n        gl.viewport(0, 0, dye.width, dye.height);\n        gl.uniform1i(splatProgram.uniforms.uTarget, dye.read.attach(0));\n        gl.uniform3f(splatProgram.uniforms.color, color.r, color.g, color.b);\n        blit(dye.write.fbo);\n        dye.swap();\n    }\n}\nfunction correctRadius(radius) {\n    let aspectRatio = canvas.width / canvas.height;\n    if (aspectRatio > 1)\n        radius *= aspectRatio;\n    return radius;\n}\ncanvas.addEventListener('mousedown', e => {\n    let posX = scaleByPixelRatio(e.offsetX);\n    let posY = scaleByPixelRatio(e.offsetY);\n    let pointer = pointers.find(p => p.id == -1);\n    if (pointer == null)\n        pointer = new Pointer();\n    updatePointerDownData(pointer, -1, posX, posY);\n});\ncanvas.addEventListener('mousemove', e => {\n    let pointer = pointers[0];\n    if (!pointer.down)\n        return;\n    let posX = scaleByPixelRatio(e.offsetX);\n    let posY = scaleByPixelRatio(e.offsetY);\n    updatePointerMoveData(pointer, posX, posY);\n});\nwindow.addEventListener('mouseup', () => {\n    updatePointerUpData(pointers[0]);\n});\ncanvas.addEventListener('touchstart', e => {\n    e.preventDefault();\n    const touches = e.targetTouches;\n    while (touches.length >= pointers.length)\n        pointers.push(new Pointer());\n    for (let i = 0; i < touches.length; i++) {\n        let posX = scaleByPixelRatio(touches[i].pageX);\n        let posY = scaleByPixelRatio(touches[i].pageY);\n        updatePointerDownData(pointers[i + 1], touches[i].identifier, posX, posY);\n    }\n});\ncanvas.addEventListener('touchmove', e => {\n    e.preventDefault();\n    const touches = e.targetTouches;\n    for (let i = 0; i < touches.length; i++) {\n        let pointer = pointers[i + 1];\n        if (!pointer.down)\n            continue;\n        let posX = scaleByPixelRatio(touches[i].pageX);\n        let posY = scaleByPixelRatio(touches[i].pageY);\n        updatePointerMoveData(pointer, posX, posY);\n    }\n}, false);\nwindow.addEventListener('touchend', e => {\n    const touches = e.changedTouches;\n    for (let i = 0; i < touches.length; i++) {\n        let pointer = pointers.find(p => p.id == touches[i].identifier);\n        if (pointer == null)\n            continue;\n        updatePointerUpData(pointer);\n    }\n});\nwindow.addEventListener('keydown', e => {\n    if (e.code === 'KeyP')\n        config.PAUSED = !config.PAUSED;\n    if (e.key === ' ')\n        splatStack.push(safeParseInt(Math.random() * 20) + 5);\n});\nfunction updatePointerDownData(pointer, id, posX, posY) {\n    pointer.id = id;\n    pointer.down = true;\n    pointer.moved = false;\n    pointer.texcoordX = posX / canvas.width;\n    pointer.texcoordY = 1.0 - posY / canvas.height;\n    pointer.prevTexcoordX = pointer.texcoordX;\n    pointer.prevTexcoordY = pointer.texcoordY;\n    pointer.deltaX = 0;\n    pointer.deltaY = 0;\n    pointer.colorUpdates = 0;\n    if (!config.RANDOM_COLOR) {\n        pointer.color = muteUIColor(config.SPLAT_COLOR);\n    }\n    else {\n        pointer.color = generateColor();\n    }\n}\nfunction updatePointerMoveData(pointer, posX, posY) {\n    pointer.prevTexcoordX = pointer.texcoordX;\n    pointer.prevTexcoordY = pointer.texcoordY;\n    pointer.texcoordX = posX / canvas.width;\n    pointer.texcoordY = 1.0 - posY / canvas.height;\n    pointer.deltaX = correctDeltaX(pointer.texcoordX - pointer.prevTexcoordX);\n    pointer.deltaY = correctDeltaY(pointer.texcoordY - pointer.prevTexcoordY);\n    pointer.moved = Math.abs(pointer.deltaX) > 0 || Math.abs(pointer.deltaY) > 0;\n}\nfunction updatePointerUpData(pointer) {\n    pointer.down = false;\n}\nfunction correctDeltaX(delta) {\n    let aspectRatio = canvas.width / canvas.height;\n    if (aspectRatio < 1)\n        delta *= aspectRatio;\n    return delta;\n}\nfunction correctDeltaY(delta) {\n    let aspectRatio = canvas.width / canvas.height;\n    if (aspectRatio > 1)\n        delta /= aspectRatio;\n    return delta;\n}\nfunction generateColor() {\n    let c = HSVtoRGB(Math.random(), 1.0, 1.0);\n    c.r *= 0.15;\n    c.g *= 0.15;\n    c.b *= 0.15;\n    return c;\n}\nfunction HSVtoRGB(h, s, v) {\n    let r = 0, g = 0, b = 0, i = 0, f = 0, p = 0, q = 0, t = 0;\n    i = Math.floor(h * 6);\n    f = h * 6 - i;\n    p = v * (1 - s);\n    q = v * (1 - f * s);\n    t = v * (1 - (1 - f) * s);\n    switch (i % 6) {\n        case 0:\n            ;\n            (r = v), (g = t), (b = p);\n            break;\n        case 1:\n            ;\n            (r = q), (g = v), (b = p);\n            break;\n        case 2:\n            ;\n            (r = p), (g = v), (b = t);\n            break;\n        case 3:\n            ;\n            (r = p), (g = q), (b = v);\n            break;\n        case 4:\n            ;\n            (r = t), (g = p), (b = v);\n            break;\n        case 5:\n            ;\n            (r = v), (g = p), (b = q);\n            break;\n    }\n    return {\n        r,\n        g,\n        b,\n    };\n}\nfunction normalizeColor(input) {\n    let output = {\n        r: input.r / 255,\n        g: input.g / 255,\n        b: input.b / 255,\n    };\n    return output;\n}\nfunction tfColor(input, tf) {\n    let output = {\n        r: tf(input.r),\n        g: tf(input.g),\n        b: tf(input.b),\n    };\n    return output;\n}\nconst muteUIColor = (color) => tfColor(color, x => x / 270 + 0.05);\nfunction wrap(value, min, max) {\n    let range = max - min;\n    if (range == 0)\n        return min;\n    return ((value - min) % range) + min;\n}\nfunction getResolution(resolution) {\n    let aspectRatio = gl.drawingBufferWidth / gl.drawingBufferHeight;\n    if (aspectRatio < 1)\n        aspectRatio = 1.0 / aspectRatio;\n    let min = Math.round(resolution);\n    let max = Math.round(resolution * aspectRatio);\n    if (gl.drawingBufferWidth > gl.drawingBufferHeight)\n        return { width: max, height: min };\n    else\n        return { width: min, height: max };\n}\nfunction getTextureScale(texture, width, height) {\n    return {\n        x: width / texture.width,\n        y: height / texture.height,\n    };\n}\nfunction scaleByPixelRatio(input) {\n    let pixelRatio = window.devicePixelRatio || 1;\n    return Math.floor(input * pixelRatio);\n}\nfunction hashCode(s) {\n    if (s.length == 0)\n        return 0;\n    let hash = 0;\n    for (let i = 0; i < s.length; i++) {\n        hash = (hash << 5) - hash + s.charCodeAt(i);\n        hash |= 0; // Convert to 32bit integer\n    }\n    return hash;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zY3JpcHQudHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zY3JpcHQudHM/NThhNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuTUlUIExpY2Vuc2VcblxuQ29weXJpZ2h0IChjKSAyMDE3IFBhdmVsIERvYnJ5YWtvdlxuVHlwZXNjcmlwdCBmb3JrIChjKSAyMDIwIEpha2UgVGV0b24tTGFuZGlzXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG5jb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG5TT0ZUV0FSRS5cbiovXG5cbmRlY2xhcmUgY29uc3QgZGF0OiB0eXBlb2YgaW1wb3J0KCdkYXQuZ3VpJylcblxuZnVuY3Rpb24gc2FmZVBhcnNlSW50KHg6IG51bWJlcikge1xuICByZXR1cm4gcGFyc2VJbnQoeC50b1N0cmluZygpKVxufVxuXG5mdW5jdGlvbiBub3ROdWxsPFQ+KHZhbHVlOiBULCBtc2c/OiBzdHJpbmcpOiBOb25OdWxsYWJsZTxUPiB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAndmFsdWUgdW5leHBlY3RlZGx5IG51bGwnKVxuICB9XG4gIHJldHVybiB2YWx1ZSBhcyBhbnkgLy8gVE9ET1xufVxuXG5jb25zdCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY2FudmFzJylbMF1cbnJlc2l6ZUNhbnZhcygpXG5cbmNvbnN0IE5hbWVkQ29sb3JzID0ge1xuICBCbGFjazogeyByOiAwLCBnOiAwLCBiOiAwIH0sXG4gIFJlZDogeyByOiAyNDUsIGc6IDAsIGI6IDAgfSxcbiAgTm90aW9uTWFya2V0aW5nQmFja2dyb3VuZDogeyByOiAyNTUsIGc6IDI1NCwgYjogMjUyIH0sXG59XG5cbmZ1bmN0aW9uIGR1cDxUPih2YWw6IFQpOiBUIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodmFsKSlcbn1cblxuY29uc3QgY29uZmlnID0ge1xuICBTSU1fUkVTT0xVVElPTjogNTEyLFxuICBEWUVfUkVTT0xVVElPTjogMTAyNCxcbiAgQ0FQVFVSRV9SRVNPTFVUSU9OOiA1MTIsXG4gIERFTlNJVFlfRElTU0lQQVRJT046IDEsXG4gIFZFTE9DSVRZX0RJU1NJUEFUSU9OOiAwLjIsXG4gIFBSRVNTVVJFOiAwLjgsXG4gIFBSRVNTVVJFX0lURVJBVElPTlM6IDIwLFxuICBDVVJMOiAzMCxcbiAgU1BMQVRfUkFESVVTOiAwLjI1LFxuICBTUExBVF9GT1JDRTogNjAwMCxcbiAgU0hBRElORzogdHJ1ZSxcbiAgU1BMQVRfQ09MT1I6IGR1cChOYW1lZENvbG9ycy5SZWQpLFxuICBSQU5ET01fQ09MT1I6IHRydWUsXG4gIENPTE9SRlVMOiB0cnVlLFxuICBDT0xPUl9VUERBVEVfU1BFRUQ6IDEwLFxuICBQQVVTRUQ6IGZhbHNlLFxuICBCQUNLX0NPTE9SOiBkdXAoTmFtZWRDb2xvcnMuQmxhY2spLFxuICBUUkFOU1BBUkVOVDogZmFsc2UsXG4gIEJMT09NOiB0cnVlLFxuICBCTE9PTV9JVEVSQVRJT05TOiA4LFxuICBCTE9PTV9SRVNPTFVUSU9OOiAyNTYsXG4gIEJMT09NX0lOVEVOU0lUWTogMC44LFxuICBCTE9PTV9USFJFU0hPTEQ6IDAuNixcbiAgQkxPT01fU09GVF9LTkVFOiAwLjcsXG4gIFNVTlJBWVM6IHRydWUsXG4gIFNVTlJBWVNfUkVTT0xVVElPTjogMTk2LFxuICBTVU5SQVlTX1dFSUdIVDogMS4wLFxufVxuXG5jbGFzcyBQb2ludGVyIHtcbiAgaWQgPSAtMVxuICB0ZXhjb29yZFggPSAwXG4gIHRleGNvb3JkWSA9IDBcbiAgcHJldlRleGNvb3JkWCA9IDBcbiAgcHJldlRleGNvb3JkWSA9IDBcbiAgZGVsdGFYID0gMFxuICBkZWx0YVkgPSAwXG4gIGRvd24gPSBmYWxzZVxuICBtb3ZlZCA9IGZhbHNlXG4gIGNvbG9yOiBDb2xvciA9IHsgcjogMCwgZzogMCwgYjogMCB9XG4gIGNvbG9yVXBkYXRlcyA9IDBcbn1cblxubGV0IHBvaW50ZXJzOiBQb2ludGVyW10gPSBbXVxubGV0IHNwbGF0U3RhY2s6IG51bWJlcltdID0gW11cbnBvaW50ZXJzLnB1c2gobmV3IFBvaW50ZXIoKSlcblxuY29uc3QgeyBnbCwgZXh0IH0gPSBnZXRXZWJHTENvbnRleHQoY2FudmFzKVxuXG5pZiAoaXNNb2JpbGUoKSkge1xuICBjb25maWcuRFlFX1JFU09MVVRJT04gPSA1MTJcbn1cbmlmICghZXh0LnN1cHBvcnRMaW5lYXJGaWx0ZXJpbmcpIHtcbiAgY29uZmlnLkRZRV9SRVNPTFVUSU9OID0gNTEyXG4gIGNvbmZpZy5TSEFESU5HID0gZmFsc2VcbiAgY29uZmlnLkJMT09NID0gZmFsc2VcbiAgY29uZmlnLlNVTlJBWVMgPSBmYWxzZVxufVxuXG5zdGFydEdVSSgpXG5cbnR5cGUgR0xUeXBlID0gV2ViR0wyUmVuZGVyaW5nQ29udGV4dCAmIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuXG5mdW5jdGlvbiBnZXRXZWJHTENvbnRleHQoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkge1xuICBjb25zdCBwYXJhbXM6IFdlYkdMQ29udGV4dEF0dHJpYnV0ZXMgPSB7XG4gICAgYWxwaGE6IHRydWUsXG4gICAgZGVwdGg6IGZhbHNlLFxuICAgIHN0ZW5jaWw6IGZhbHNlLFxuICAgIGFudGlhbGlhczogZmFsc2UsXG4gICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZSxcbiAgfVxuXG4gIGNvbnN0IGdsMiA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbDInLCBwYXJhbXMpXG4gIGNvbnN0IGdsOiBHTFR5cGUgPVxuICAgIGdsMiB8fFxuICAgIGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIHBhcmFtcykgfHxcbiAgICAoY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIHBhcmFtcykgYXMgYW55KVxuICBjb25zdCBpc1dlYkdMMiA9ICEhZ2wyXG5cbiAgbGV0IGhhbGZGbG9hdDogT0VTX3RleHR1cmVfaGFsZl9mbG9hdCA9IHVuZGVmaW5lZCBhcyBhbnlcbiAgbGV0IHN1cHBvcnRMaW5lYXJGaWx0ZXJpbmc6IE9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhciB8IE9FU190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyXG4gIGlmIChpc1dlYkdMMikge1xuICAgIGdsLmdldEV4dGVuc2lvbignRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCcpXG4gICAgc3VwcG9ydExpbmVhckZpbHRlcmluZyA9IGdsLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJykhXG4gIH0gZWxzZSB7XG4gICAgaGFsZkZsb2F0ID0gZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0JykhXG4gICAgc3VwcG9ydExpbmVhckZpbHRlcmluZyA9IGdsLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXInKSFcbiAgfVxuXG4gIGdsLmNsZWFyQ29sb3IoMC4wLCAwLjAsIDAuMCwgMS4wKVxuXG4gIGNvbnN0IGhhbGZGbG9hdFRleFR5cGUgPSBpc1dlYkdMMiA/IGdsLkhBTEZfRkxPQVQgOiBoYWxmRmxvYXQuSEFMRl9GTE9BVF9PRVNcbiAgbGV0IGZvcm1hdFJHQkE6IFJldHVyblR5cGU8dHlwZW9mIGdldFN1cHBvcnRlZEZvcm1hdD5cbiAgbGV0IGZvcm1hdFJHOiBSZXR1cm5UeXBlPHR5cGVvZiBnZXRTdXBwb3J0ZWRGb3JtYXQ+XG4gIGxldCBmb3JtYXRSOiBSZXR1cm5UeXBlPHR5cGVvZiBnZXRTdXBwb3J0ZWRGb3JtYXQ+XG5cbiAgaWYgKGlzV2ViR0wyKSB7XG4gICAgZm9ybWF0UkdCQSA9IGdldFN1cHBvcnRlZEZvcm1hdChnbCwgZ2wuUkdCQTE2RiwgZ2wuUkdCQSwgaGFsZkZsb2F0VGV4VHlwZSlcbiAgICBmb3JtYXRSRyA9IGdldFN1cHBvcnRlZEZvcm1hdChnbCwgZ2wuUkcxNkYsIGdsLlJHLCBoYWxmRmxvYXRUZXhUeXBlKVxuICAgIGZvcm1hdFIgPSBnZXRTdXBwb3J0ZWRGb3JtYXQoZ2wsIGdsLlIxNkYsIGdsLlJFRCwgaGFsZkZsb2F0VGV4VHlwZSlcbiAgfSBlbHNlIHtcbiAgICBmb3JtYXRSR0JBID0gZ2V0U3VwcG9ydGVkRm9ybWF0KGdsLCBnbC5SR0JBLCBnbC5SR0JBLCBoYWxmRmxvYXRUZXhUeXBlKVxuICAgIGZvcm1hdFJHID0gZ2V0U3VwcG9ydGVkRm9ybWF0KGdsLCBnbC5SR0JBLCBnbC5SR0JBLCBoYWxmRmxvYXRUZXhUeXBlKVxuICAgIGZvcm1hdFIgPSBnZXRTdXBwb3J0ZWRGb3JtYXQoZ2wsIGdsLlJHQkEsIGdsLlJHQkEsIGhhbGZGbG9hdFRleFR5cGUpXG4gIH1cblxuICAvLyBBc3N1bWVzIGdsb2JhbCBHb29nbGUgQW5hbHl0aWNzLCBkaXNhYmxlZC5cbiAgLy9nYSgnc2VuZCcsICdldmVudCcsIGlzV2ViR0wyID8gJ3dlYmdsMicgOiAnd2ViZ2wnLCBmb3JtYXRSR0JBID09IG51bGwgPyAnbm90IHN1cHBvcnRlZCcgOiAnc3VwcG9ydGVkJyk7XG5cbiAgcmV0dXJuIHtcbiAgICBnbCxcbiAgICBleHQ6IHtcbiAgICAgIGZvcm1hdFJHQkEsXG4gICAgICBmb3JtYXRSRyxcbiAgICAgIGZvcm1hdFIsXG4gICAgICBoYWxmRmxvYXRUZXhUeXBlLFxuICAgICAgc3VwcG9ydExpbmVhckZpbHRlcmluZyxcbiAgICB9LFxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFN1cHBvcnRlZEZvcm1hdChcbiAgZ2w6IEdMVHlwZSxcbiAgaW50ZXJuYWxGb3JtYXQ6IG51bWJlcixcbiAgZm9ybWF0OiBudW1iZXIsXG4gIHR5cGU6IG51bWJlclxuKTogeyBpbnRlcm5hbEZvcm1hdDogbnVtYmVyOyBmb3JtYXQ6IG51bWJlciB9IHtcbiAgLyoqIFRPRE86IHwgbnVsbCAqL1xuICBpZiAoIXN1cHBvcnRSZW5kZXJUZXh0dXJlRm9ybWF0KGdsLCBpbnRlcm5hbEZvcm1hdCwgZm9ybWF0LCB0eXBlKSkge1xuICAgIHN3aXRjaCAoaW50ZXJuYWxGb3JtYXQpIHtcbiAgICAgIGNhc2UgZ2wuUjE2RjpcbiAgICAgICAgcmV0dXJuIGdldFN1cHBvcnRlZEZvcm1hdChnbCwgZ2wuUkcxNkYsIGdsLlJHLCB0eXBlKVxuICAgICAgY2FzZSBnbC5SRzE2RjpcbiAgICAgICAgcmV0dXJuIGdldFN1cHBvcnRlZEZvcm1hdChnbCwgZ2wuUkdCQTE2RiwgZ2wuUkdCQSwgdHlwZSlcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsIGFzIGFueSAvLyBUT0RPXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBpbnRlcm5hbEZvcm1hdCxcbiAgICBmb3JtYXQsXG4gIH1cbn1cblxuZnVuY3Rpb24gc3VwcG9ydFJlbmRlclRleHR1cmVGb3JtYXQoXG4gIGdsOiBHTFR5cGUsXG4gIGludGVybmFsRm9ybWF0OiBudW1iZXIsXG4gIGZvcm1hdDogbnVtYmVyLFxuICB0eXBlOiBudW1iZXJcbikge1xuICBsZXQgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKVxuICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKVxuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVClcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpXG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpXG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpXG4gIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgaW50ZXJuYWxGb3JtYXQsIDQsIDQsIDAsIGZvcm1hdCwgdHlwZSwgbnVsbClcblxuICBsZXQgZmJvID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKVxuICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZibylcbiAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlLCAwKVxuXG4gIGNvbnN0IHN0YXR1cyA9IGdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoZ2wuRlJBTUVCVUZGRVIpXG4gIHJldHVybiBzdGF0dXMgPT0gZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEVcbn1cblxuZnVuY3Rpb24gc3RhcnRHVUkoKSB7XG4gIHZhciBndWkgPSBuZXcgZGF0LkdVSSh7IHdpZHRoOiAzMDAgfSlcbiAgZ3VpXG4gICAgLmFkZChjb25maWcsICdEWUVfUkVTT0xVVElPTicsIHtcbiAgICAgIHVsdHJhOiAyMDQ4LFxuICAgICAgaGlnaDogMTAyNCxcbiAgICAgIG1lZGl1bTogNTEyLFxuICAgICAgbG93OiAyNTYsXG4gICAgICAndmVyeSBsb3cnOiAxMjgsXG4gICAgfSlcbiAgICAubmFtZSgncXVhbGl0eScpXG4gICAgLm9uRmluaXNoQ2hhbmdlKGluaXRGcmFtZWJ1ZmZlcnMpXG4gIGd1aVxuICAgIC5hZGQoY29uZmlnLCAnU0lNX1JFU09MVVRJT04nLCB7ICczMic6IDMyLCAnNjQnOiA2NCwgJzEyOCc6IDEyOCwgJzI1Nic6IDI1NiwgJzUxMic6IDUxMiB9KVxuICAgIC5uYW1lKCdzaW0gcmVzb2x1dGlvbicpXG4gICAgLm9uRmluaXNoQ2hhbmdlKGluaXRGcmFtZWJ1ZmZlcnMpXG4gIGd1aS5hZGQoY29uZmlnLCAnREVOU0lUWV9ESVNTSVBBVElPTicsIDAsIDQuMCkubmFtZSgnZGVuc2l0eSBkaWZmdXNpb24nKVxuICBndWkuYWRkKGNvbmZpZywgJ1ZFTE9DSVRZX0RJU1NJUEFUSU9OJywgMCwgNC4wKS5uYW1lKCd2ZWxvY2l0eSBkaWZmdXNpb24nKVxuICBndWkuYWRkKGNvbmZpZywgJ1BSRVNTVVJFJywgMC4wLCAxLjApLm5hbWUoJ3ByZXNzdXJlJylcbiAgZ3VpXG4gICAgLmFkZChjb25maWcsICdDVVJMJywgMCwgNTApXG4gICAgLm5hbWUoJ3ZvcnRpY2l0eScpXG4gICAgLnN0ZXAoMSlcbiAgZ3VpLmFkZChjb25maWcsICdTUExBVF9SQURJVVMnLCAwLjAxLCAxLjApLm5hbWUoJ3NwbGF0IHJhZGl1cycpXG4gIGd1aVxuICAgIC5hZGQoY29uZmlnLCAnU0hBRElORycpXG4gICAgLm5hbWUoJ3NoYWRpbmcnKVxuICAgIC5vbkZpbmlzaENoYW5nZSh1cGRhdGVLZXl3b3JkcylcbiAgZ3VpLmFkZENvbG9yKGNvbmZpZywgJ1NQTEFUX0NPTE9SJykubmFtZSgnU3BsYXQgY29sb3InKVxuICBndWkuYWRkKGNvbmZpZywgJ1JBTkRPTV9DT0xPUicpLm5hbWUoJ1VzZSByYW5kb20gY29sb3InKVxuICBndWkuYWRkKGNvbmZpZywgJ0NPTE9SRlVMJykubmFtZSgnUGFpbnQgdGhlIHJhaW5ib3cnKVxuICBndWlcbiAgICAuYWRkKGNvbmZpZywgJ1BBVVNFRCcpXG4gICAgLm5hbWUoJ3BhdXNlZCcpXG4gICAgLmxpc3RlbigpXG5cbiAgZ3VpXG4gICAgLmFkZChcbiAgICAgIHtcbiAgICAgICAgZnVuOiAoKSA9PiB7XG4gICAgICAgICAgc3BsYXRTdGFjay5wdXNoKHNhZmVQYXJzZUludChNYXRoLnJhbmRvbSgpICogMjApICsgNSlcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICAnZnVuJ1xuICAgIClcbiAgICAubmFtZSgnUmFuZG9tIHNwbGF0cycpXG5cbiAgbGV0IGJsb29tRm9sZGVyID0gZ3VpLmFkZEZvbGRlcignQmxvb20nKVxuICBibG9vbUZvbGRlclxuICAgIC5hZGQoY29uZmlnLCAnQkxPT00nKVxuICAgIC5uYW1lKCdlbmFibGVkJylcbiAgICAub25GaW5pc2hDaGFuZ2UodXBkYXRlS2V5d29yZHMpXG4gIGJsb29tRm9sZGVyLmFkZChjb25maWcsICdCTE9PTV9JTlRFTlNJVFknLCAwLjEsIDIuMCkubmFtZSgnaW50ZW5zaXR5JylcbiAgYmxvb21Gb2xkZXIuYWRkKGNvbmZpZywgJ0JMT09NX1RIUkVTSE9MRCcsIDAuMCwgMS4wKS5uYW1lKCd0aHJlc2hvbGQnKVxuXG4gIGxldCBzdW5yYXlzRm9sZGVyID0gZ3VpLmFkZEZvbGRlcignU3VucmF5cycpXG4gIHN1bnJheXNGb2xkZXJcbiAgICAuYWRkKGNvbmZpZywgJ1NVTlJBWVMnKVxuICAgIC5uYW1lKCdlbmFibGVkJylcbiAgICAub25GaW5pc2hDaGFuZ2UodXBkYXRlS2V5d29yZHMpXG4gIHN1bnJheXNGb2xkZXIuYWRkKGNvbmZpZywgJ1NVTlJBWVNfV0VJR0hUJywgMC4zLCAxLjApLm5hbWUoJ3dlaWdodCcpXG5cbiAgbGV0IGNhcHR1cmVGb2xkZXIgPSBndWkuYWRkRm9sZGVyKCdDYXB0dXJlJylcbiAgY2FwdHVyZUZvbGRlci5hZGRDb2xvcihjb25maWcsICdCQUNLX0NPTE9SJykubmFtZSgnYmFja2dyb3VuZCBjb2xvcicpXG4gIGNhcHR1cmVGb2xkZXIuYWRkKGNvbmZpZywgJ1RSQU5TUEFSRU5UJykubmFtZSgndHJhbnNwYXJlbnQnKVxuICBjYXB0dXJlRm9sZGVyLmFkZCh7IGZ1bjogY2FwdHVyZVNjcmVlbnNob3QgfSwgJ2Z1bicpLm5hbWUoJ3Rha2Ugc2NyZWVuc2hvdCcpXG5cbiAgdHlwZSBHVUlDb250cm9sbGVyTGlzdEl0ZW0gPSBkYXQuR1VJQ29udHJvbGxlciAmIHsgX19saTogSFRNTE9MaXN0RWxlbWVudCB9XG5cbiAgbGV0IGdpdGh1YiA9IGd1aVxuICAgIC5hZGQoXG4gICAgICB7XG4gICAgICAgIGZ1bjogKCkgPT4ge1xuICAgICAgICAgIHdpbmRvdy5vcGVuKCdodHRwczovL2dpdGh1Yi5jb20vanVzdGpha2UvV2ViR0wtRmx1aWQtU2ltdWxhdGlvbicpXG4gICAgICAgICAgLy9nYSgnc2VuZCcsICdldmVudCcsICdsaW5rIGJ1dHRvbicsICdnaXRodWInKTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICAnZnVuJ1xuICAgIClcbiAgICAubmFtZSgnVHlwZXNjcmlwdCcpIGFzIEdVSUNvbnRyb2xsZXJMaXN0SXRlbVxuICBnaXRodWIuX19saS5jbGFzc05hbWUgPSAnY3IgZnVuY3Rpb24gYmlnRm9udCdcbiAgZ2l0aHViLl9fbGkuc3R5bGUuYm9yZGVyTGVmdCA9ICczcHggc29saWQgIzhDOEM4QydcbiAgbGV0IGdpdGh1Ykljb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJylcbiAgZ2l0aHViLmRvbUVsZW1lbnQucGFyZW50RWxlbWVudCEuYXBwZW5kQ2hpbGQoZ2l0aHViSWNvbilcbiAgZ2l0aHViSWNvbi5jbGFzc05hbWUgPSAnaWNvbiBnaXRodWInXG5cbiAgbGV0IG9yaWdpbmFsID0gZ3VpXG4gICAgLmFkZChcbiAgICAgIHtcbiAgICAgICAgZnVuOiAoKSA9PiB7XG4gICAgICAgICAgd2luZG93Lm9wZW4oJ2h0dHBzOi8vZ2l0aHViLmNvbS9QYXZlbERvR3JlYXQvV2ViR0wtRmx1aWQtU2ltdWxhdGlvbicpXG4gICAgICAgICAgLy9nYSgnc2VuZCcsICdldmVudCcsICdsaW5rIGJ1dHRvbicsICdnaXRodWInKTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICAnZnVuJ1xuICAgIClcbiAgICAubmFtZSgnT3JpZ2luYWwnKSBhcyBHVUlDb250cm9sbGVyTGlzdEl0ZW1cbiAgb3JpZ2luYWwuX19saS5jbGFzc05hbWUgPSAnY3IgZnVuY3Rpb24gYmlnRm9udCdcbiAgb3JpZ2luYWwuX19saS5zdHlsZS5ib3JkZXJMZWZ0ID0gJzNweCBzb2xpZCAjOEM4QzhDJ1xuICBsZXQgb3JpZ2luYWxHaXRodWJJY29uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpXG4gIG9yaWdpbmFsLmRvbUVsZW1lbnQucGFyZW50RWxlbWVudCEuYXBwZW5kQ2hpbGQob3JpZ2luYWxHaXRodWJJY29uKVxuICBvcmlnaW5hbEdpdGh1Ykljb24uY2xhc3NOYW1lID0gJ2ljb24gZ2l0aHViJ1xuXG4gIGlmIChpc01vYmlsZSgpKSBndWkuY2xvc2UoKVxufVxuXG5mdW5jdGlvbiBpc01vYmlsZSgpIHtcbiAgcmV0dXJuIC9Nb2JpfEFuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpXG59XG5cbmZ1bmN0aW9uIGNhcHR1cmVTY3JlZW5zaG90KCkge1xuICBsZXQgcmVzID0gZ2V0UmVzb2x1dGlvbihjb25maWcuQ0FQVFVSRV9SRVNPTFVUSU9OKVxuICBsZXQgdGFyZ2V0ID0gY3JlYXRlRkJPKFxuICAgIHJlcy53aWR0aCxcbiAgICByZXMuaGVpZ2h0LFxuICAgIGV4dC5mb3JtYXRSR0JBLmludGVybmFsRm9ybWF0LFxuICAgIGV4dC5mb3JtYXRSR0JBLmZvcm1hdCxcbiAgICBleHQuaGFsZkZsb2F0VGV4VHlwZSxcbiAgICBnbC5ORUFSRVNUXG4gIClcbiAgcmVuZGVyKHRhcmdldClcblxuICBsZXQgdGV4dHVyZTogVWludDhBcnJheSB8IEZsb2F0MzJBcnJheSA9IGZyYW1lYnVmZmVyVG9UZXh0dXJlKHRhcmdldClcbiAgdGV4dHVyZSA9IG5vcm1hbGl6ZVRleHR1cmUodGV4dHVyZSwgdGFyZ2V0LndpZHRoLCB0YXJnZXQuaGVpZ2h0KVxuXG4gIGxldCBjYXB0dXJlQ2FudmFzID0gdGV4dHVyZVRvQ2FudmFzKHRleHR1cmUsIHRhcmdldC53aWR0aCwgdGFyZ2V0LmhlaWdodClcbiAgbGV0IGRhdGF1cmkgPSBjYXB0dXJlQ2FudmFzLnRvRGF0YVVSTCgpXG4gIGRvd25sb2FkVVJJKCdmbHVpZC5wbmcnLCBkYXRhdXJpKVxuICBVUkwucmV2b2tlT2JqZWN0VVJMKGRhdGF1cmkpXG59XG5cbmZ1bmN0aW9uIGZyYW1lYnVmZmVyVG9UZXh0dXJlKHRhcmdldDogRkJPKSB7XG4gIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGFyZ2V0LmZibylcbiAgbGV0IGxlbmd0aCA9IHRhcmdldC53aWR0aCAqIHRhcmdldC5oZWlnaHQgKiA0XG4gIGxldCB0ZXh0dXJlID0gbmV3IEZsb2F0MzJBcnJheShsZW5ndGgpXG4gIGdsLnJlYWRQaXhlbHMoMCwgMCwgdGFyZ2V0LndpZHRoLCB0YXJnZXQuaGVpZ2h0LCBnbC5SR0JBLCBnbC5GTE9BVCwgdGV4dHVyZSlcbiAgcmV0dXJuIHRleHR1cmVcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVGV4dHVyZSh0ZXh0dXJlOiBGbG9hdDMyQXJyYXksIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKSB7XG4gIGxldCByZXN1bHQgPSBuZXcgVWludDhBcnJheSh0ZXh0dXJlLmxlbmd0aClcbiAgbGV0IGlkID0gMFxuICBmb3IgKGxldCBpID0gaGVpZ2h0IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpZHRoOyBqKyspIHtcbiAgICAgIGxldCBuaWQgPSBpICogd2lkdGggKiA0ICsgaiAqIDRcbiAgICAgIHJlc3VsdFtuaWQgKyAwXSA9IGNsYW1wMDEodGV4dHVyZVtpZCArIDBdKSAqIDI1NVxuICAgICAgcmVzdWx0W25pZCArIDFdID0gY2xhbXAwMSh0ZXh0dXJlW2lkICsgMV0pICogMjU1XG4gICAgICByZXN1bHRbbmlkICsgMl0gPSBjbGFtcDAxKHRleHR1cmVbaWQgKyAyXSkgKiAyNTVcbiAgICAgIHJlc3VsdFtuaWQgKyAzXSA9IGNsYW1wMDEodGV4dHVyZVtpZCArIDNdKSAqIDI1NVxuICAgICAgaWQgKz0gNFxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGNsYW1wMDEoaW5wdXQ6IG51bWJlcikge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoaW5wdXQsIDApLCAxKVxufVxuXG5mdW5jdGlvbiB0ZXh0dXJlVG9DYW52YXModGV4dHVyZTogVWludDhBcnJheSwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpIHtcbiAgbGV0IGNhcHR1cmVDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICBsZXQgY3R4ID0gbm90TnVsbChjYXB0dXJlQ2FudmFzLmdldENvbnRleHQoJzJkJyksICdjYW52YXMuZ2V0Q29udGV4dCgyZCknKVxuICBjYXB0dXJlQ2FudmFzLndpZHRoID0gd2lkdGhcbiAgY2FwdHVyZUNhbnZhcy5oZWlnaHQgPSBoZWlnaHRcblxuICBsZXQgaW1hZ2VEYXRhID0gY3R4LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0KVxuICBpbWFnZURhdGEuZGF0YS5zZXQodGV4dHVyZSlcbiAgY3R4LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApXG5cbiAgcmV0dXJuIGNhcHR1cmVDYW52YXNcbn1cblxuZnVuY3Rpb24gZG93bmxvYWRVUkkoZmlsZW5hbWU6IHN0cmluZywgdXJpOiBzdHJpbmcpIHtcbiAgbGV0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJylcbiAgbGluay5kb3dubG9hZCA9IGZpbGVuYW1lXG4gIGxpbmsuaHJlZiA9IHVyaVxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxpbmspXG4gIGxpbmsuY2xpY2soKVxuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGxpbmspXG59XG5cbmNsYXNzIE1hdGVyaWFsIHtcbiAgcHJvZ3JhbXM6IFdlYkdMUHJvZ3JhbVtdID0gW11cbiAgYWN0aXZlUHJvZ3JhbTogV2ViR0xQcm9ncmFtIHwgbnVsbCA9IG51bGxcbiAgdW5pZm9ybXM6IFVuaWZvcm1zIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyB2ZXJ0ZXhTaGFkZXI6IFdlYkdMU2hhZGVyLCBwdWJsaWMgZnJhZ21lbnRTaGFkZXJTb3VyY2U6IHN0cmluZykge31cblxuICBzZXRLZXl3b3JkcyhrZXl3b3Jkczogc3RyaW5nW10pIHtcbiAgICBsZXQgaGFzaCA9IDBcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXdvcmRzLmxlbmd0aDsgaSsrKSBoYXNoICs9IGhhc2hDb2RlKGtleXdvcmRzW2ldKVxuXG4gICAgbGV0IHByb2dyYW06IFdlYkdMUHJvZ3JhbSB8IG51bGwgPSB0aGlzLnByb2dyYW1zW2hhc2hdXG4gICAgaWYgKHByb2dyYW0gPT0gbnVsbCkge1xuICAgICAgbGV0IGZyYWdtZW50U2hhZGVyID0gY29tcGlsZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIsIHRoaXMuZnJhZ21lbnRTaGFkZXJTb3VyY2UsIGtleXdvcmRzKVxuICAgICAgcHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW0odGhpcy52ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyKVxuICAgICAgdGhpcy5wcm9ncmFtc1toYXNoXSA9IHByb2dyYW1cbiAgICB9XG5cbiAgICBpZiAocHJvZ3JhbSA9PSB0aGlzLmFjdGl2ZVByb2dyYW0pIHJldHVyblxuXG4gICAgdGhpcy51bmlmb3JtcyA9IGdldFVuaWZvcm1zKHByb2dyYW0pXG4gICAgdGhpcy5hY3RpdmVQcm9ncmFtID0gcHJvZ3JhbVxuICB9XG5cbiAgYmluZCgpIHtcbiAgICBnbC51c2VQcm9ncmFtKHRoaXMuYWN0aXZlUHJvZ3JhbSlcbiAgfVxufVxuXG5jbGFzcyBQcm9ncmFtIHtcbiAgcHJvZ3JhbTogV2ViR0xQcm9ncmFtXG4gIHVuaWZvcm1zOiBVbmlmb3Jtc1xuICBjb25zdHJ1Y3Rvcih2ZXJ0ZXhTaGFkZXI6IFdlYkdMU2hhZGVyLCBmcmFnbWVudFNoYWRlcjogV2ViR0xTaGFkZXIpIHtcbiAgICB0aGlzLnByb2dyYW0gPSBjcmVhdGVQcm9ncmFtKHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIpXG4gICAgdGhpcy51bmlmb3JtcyA9IGdldFVuaWZvcm1zKHRoaXMucHJvZ3JhbSlcbiAgfVxuXG4gIGJpbmQoKSB7XG4gICAgZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbSh2ZXJ0ZXhTaGFkZXI6IFdlYkdMU2hhZGVyLCBmcmFnbWVudFNoYWRlcjogV2ViR0xTaGFkZXIpIHtcbiAgbGV0IHByb2dyYW0gPSBub3ROdWxsKGdsLmNyZWF0ZVByb2dyYW0oKSlcbiAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcilcbiAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKVxuICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKVxuXG4gIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHRocm93IGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pXG5cbiAgcmV0dXJuIHByb2dyYW1cbn1cblxudHlwZSBVbmlmb3JtcyA9IHsgW2tleTogc3RyaW5nXTogV2ViR0xVbmlmb3JtTG9jYXRpb24gfVxuXG5mdW5jdGlvbiBnZXRVbmlmb3Jtcyhwcm9ncmFtOiBXZWJHTFByb2dyYW0pIHtcbiAgbGV0IHVuaWZvcm1zOiBVbmlmb3JtcyA9IFtdIGFzIGFueSAvLyBUT0RPIHN3aXRjaCB0byB7fSBpZiBwb3NzaWJsZVxuICBsZXQgdW5pZm9ybUNvdW50ID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5BQ1RJVkVfVU5JRk9STVMpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdW5pZm9ybUNvdW50OyBpKyspIHtcbiAgICBsZXQgdW5pZm9ybU5hbWUgPSBub3ROdWxsKGdsLmdldEFjdGl2ZVVuaWZvcm0ocHJvZ3JhbSwgaSkpLm5hbWVcbiAgICB1bmlmb3Jtc1t1bmlmb3JtTmFtZV0gPSBub3ROdWxsKGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCB1bmlmb3JtTmFtZSkpXG4gIH1cbiAgcmV0dXJuIHVuaWZvcm1zXG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVTaGFkZXIodHlwZTogbnVtYmVyLCBzb3VyY2U6IHN0cmluZywga2V5d29yZHM/OiBzdHJpbmdbXSkge1xuICBzb3VyY2UgPSBhZGRLZXl3b3Jkcyhzb3VyY2UsIGtleXdvcmRzKVxuXG4gIGNvbnN0IHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcih0eXBlKVxuICBpZiAoIXNoYWRlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGNyZWF0ZSBzaGFkZXIgdHlwZSAke3R5cGV9YClcbiAgfVxuICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpXG4gIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKVxuXG4gIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB0aHJvdyBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcilcblxuICByZXR1cm4gc2hhZGVyXG59XG5cbmZ1bmN0aW9uIGFkZEtleXdvcmRzKHNvdXJjZTogc3RyaW5nLCBrZXl3b3Jkcz86IHN0cmluZ1tdKSB7XG4gIGlmIChrZXl3b3JkcyA9PSBudWxsKSByZXR1cm4gc291cmNlXG4gIGxldCBrZXl3b3Jkc1N0cmluZyA9ICcnXG4gIGtleXdvcmRzLmZvckVhY2goa2V5d29yZCA9PiB7XG4gICAga2V5d29yZHNTdHJpbmcgKz0gJyNkZWZpbmUgJyArIGtleXdvcmQgKyAnXFxuJ1xuICB9KVxuICByZXR1cm4ga2V5d29yZHNTdHJpbmcgKyBzb3VyY2Vcbn1cblxuY29uc3QgYmFzZVZlcnRleFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gIGdsLlZFUlRFWF9TSEFERVIsXG4gIGBcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG5cbiAgICBhdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb247XG4gICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICB2YXJ5aW5nIHZlYzIgdkw7XG4gICAgdmFyeWluZyB2ZWMyIHZSO1xuICAgIHZhcnlpbmcgdmVjMiB2VDtcbiAgICB2YXJ5aW5nIHZlYzIgdkI7XG4gICAgdW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTtcblxuICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgIHZVdiA9IGFQb3NpdGlvbiAqIDAuNSArIDAuNTtcbiAgICAgICAgdkwgPSB2VXYgLSB2ZWMyKHRleGVsU2l6ZS54LCAwLjApO1xuICAgICAgICB2UiA9IHZVdiArIHZlYzIodGV4ZWxTaXplLngsIDAuMCk7XG4gICAgICAgIHZUID0gdlV2ICsgdmVjMigwLjAsIHRleGVsU2l6ZS55KTtcbiAgICAgICAgdkIgPSB2VXYgLSB2ZWMyKDAuMCwgdGV4ZWxTaXplLnkpO1xuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoYVBvc2l0aW9uLCAwLjAsIDEuMCk7XG4gICAgfVxuYFxuKVxuXG5jb25zdCBibHVyVmVydGV4U2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgZ2wuVkVSVEVYX1NIQURFUixcbiAgYFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcblxuICAgIGF0dHJpYnV0ZSB2ZWMyIGFQb3NpdGlvbjtcbiAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgIHZhcnlpbmcgdmVjMiB2TDtcbiAgICB2YXJ5aW5nIHZlYzIgdlI7XG4gICAgdW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTtcblxuICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgIHZVdiA9IGFQb3NpdGlvbiAqIDAuNSArIDAuNTtcbiAgICAgICAgZmxvYXQgb2Zmc2V0ID0gMS4zMzMzMzMzMztcbiAgICAgICAgdkwgPSB2VXYgLSB0ZXhlbFNpemUgKiBvZmZzZXQ7XG4gICAgICAgIHZSID0gdlV2ICsgdGV4ZWxTaXplICogb2Zmc2V0O1xuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoYVBvc2l0aW9uLCAwLjAsIDEuMCk7XG4gICAgfVxuYFxuKVxuXG5jb25zdCBibHVyU2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgZ2wuRlJBR01FTlRfU0hBREVSLFxuICBgXG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgc2FtcGxlcjJEO1xuXG4gICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICB2YXJ5aW5nIHZlYzIgdkw7XG4gICAgdmFyeWluZyB2ZWMyIHZSO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xuXG4gICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgdmVjNCBzdW0gPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZVdikgKiAwLjI5NDExNzY0O1xuICAgICAgICBzdW0gKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2TCkgKiAwLjM1Mjk0MTE3O1xuICAgICAgICBzdW0gKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2UikgKiAwLjM1Mjk0MTE3O1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSBzdW07XG4gICAgfVxuYFxuKVxuXG5jb25zdCBjb3B5U2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgZ2wuRlJBR01FTlRfU0hBREVSLFxuICBgXG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgc2FtcGxlcjJEO1xuXG4gICAgdmFyeWluZyBoaWdocCB2ZWMyIHZVdjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcblxuICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlV2KTtcbiAgICB9XG5gXG4pXG5cbmNvbnN0IGNsZWFyU2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgZ2wuRlJBR01FTlRfU0hBREVSLFxuICBgXG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgc2FtcGxlcjJEO1xuXG4gICAgdmFyeWluZyBoaWdocCB2ZWMyIHZVdjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcbiAgICB1bmlmb3JtIGZsb2F0IHZhbHVlO1xuXG4gICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmFsdWUgKiB0ZXh0dXJlMkQodVRleHR1cmUsIHZVdik7XG4gICAgfVxuYFxuKVxuXG5jb25zdCBjb2xvclNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gIGdsLkZSQUdNRU5UX1NIQURFUixcbiAgYFxuICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXG4gICAgdW5pZm9ybSB2ZWM0IGNvbG9yO1xuXG4gICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XG4gICAgfVxuYFxuKVxuXG5jb25zdCBjaGVja2VyYm9hcmRTaGFkZXIgPSBjb21waWxlU2hhZGVyKFxuICBnbC5GUkFHTUVOVF9TSEFERVIsXG4gIGBcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgcHJlY2lzaW9uIGhpZ2hwIHNhbXBsZXIyRDtcblxuICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XG4gICAgdW5pZm9ybSBmbG9hdCBhc3BlY3RSYXRpbztcblxuICAgICNkZWZpbmUgU0NBTEUgMjUuMFxuXG4gICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgdmVjMiB1diA9IGZsb29yKHZVdiAqIFNDQUxFICogdmVjMihhc3BlY3RSYXRpbywgMS4wKSk7XG4gICAgICAgIGZsb2F0IHYgPSBtb2QodXYueCArIHV2LnksIDIuMCk7XG4gICAgICAgIHYgPSB2ICogMC4xICsgMC44O1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZlYzModiksIDEuMCk7XG4gICAgfVxuYFxuKVxuXG5jb25zdCBkaXNwbGF5U2hhZGVyU291cmNlID0gYFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICBwcmVjaXNpb24gaGlnaHAgc2FtcGxlcjJEO1xuXG4gICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICB2YXJ5aW5nIHZlYzIgdkw7XG4gICAgdmFyeWluZyB2ZWMyIHZSO1xuICAgIHZhcnlpbmcgdmVjMiB2VDtcbiAgICB2YXJ5aW5nIHZlYzIgdkI7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdUJsb29tO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVTdW5yYXlzO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVEaXRoZXJpbmc7XG4gICAgdW5pZm9ybSB2ZWMyIGRpdGhlclNjYWxlO1xuICAgIHVuaWZvcm0gdmVjMiB0ZXhlbFNpemU7XG5cbiAgICB2ZWMzIGxpbmVhclRvR2FtbWEgKHZlYzMgY29sb3IpIHtcbiAgICAgICAgY29sb3IgPSBtYXgoY29sb3IsIHZlYzMoMCkpO1xuICAgICAgICByZXR1cm4gbWF4KDEuMDU1ICogcG93KGNvbG9yLCB2ZWMzKDAuNDE2NjY2NjY3KSkgLSAwLjA1NSwgdmVjMygwKSk7XG4gICAgfVxuXG4gICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgdmVjMyBjID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VXYpLnJnYjtcblxuICAgICNpZmRlZiBTSEFESU5HXG4gICAgICAgIHZlYzMgbGMgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZMKS5yZ2I7XG4gICAgICAgIHZlYzMgcmMgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZSKS5yZ2I7XG4gICAgICAgIHZlYzMgdGMgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUKS5yZ2I7XG4gICAgICAgIHZlYzMgYmMgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZCKS5yZ2I7XG5cbiAgICAgICAgZmxvYXQgZHggPSBsZW5ndGgocmMpIC0gbGVuZ3RoKGxjKTtcbiAgICAgICAgZmxvYXQgZHkgPSBsZW5ndGgodGMpIC0gbGVuZ3RoKGJjKTtcblxuICAgICAgICB2ZWMzIG4gPSBub3JtYWxpemUodmVjMyhkeCwgZHksIGxlbmd0aCh0ZXhlbFNpemUpKSk7XG4gICAgICAgIHZlYzMgbCA9IHZlYzMoMC4wLCAwLjAsIDEuMCk7XG5cbiAgICAgICAgZmxvYXQgZGlmZnVzZSA9IGNsYW1wKGRvdChuLCBsKSArIDAuNywgMC43LCAxLjApO1xuICAgICAgICBjICo9IGRpZmZ1c2U7XG4gICAgI2VuZGlmXG5cbiAgICAjaWZkZWYgQkxPT01cbiAgICAgICAgdmVjMyBibG9vbSA9IHRleHR1cmUyRCh1Qmxvb20sIHZVdikucmdiO1xuICAgICNlbmRpZlxuXG4gICAgI2lmZGVmIFNVTlJBWVNcbiAgICAgICAgZmxvYXQgc3VucmF5cyA9IHRleHR1cmUyRCh1U3VucmF5cywgdlV2KS5yO1xuICAgICAgICBjICo9IHN1bnJheXM7XG4gICAgI2lmZGVmIEJMT09NXG4gICAgICAgIGJsb29tICo9IHN1bnJheXM7XG4gICAgI2VuZGlmXG4gICAgI2VuZGlmXG5cbiAgICAjaWZkZWYgQkxPT01cbiAgICAgICAgZmxvYXQgbm9pc2UgPSB0ZXh0dXJlMkQodURpdGhlcmluZywgdlV2ICogZGl0aGVyU2NhbGUpLnI7XG4gICAgICAgIG5vaXNlID0gbm9pc2UgKiAyLjAgLSAxLjA7XG4gICAgICAgIGJsb29tICs9IG5vaXNlIC8gMjU1LjA7XG4gICAgICAgIGJsb29tID0gbGluZWFyVG9HYW1tYShibG9vbSk7XG4gICAgICAgIGMgKz0gYmxvb207XG4gICAgI2VuZGlmXG5cbiAgICAgICAgZmxvYXQgYSA9IG1heChjLnIsIG1heChjLmcsIGMuYikpO1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGMsIGEpO1xuICAgIH1cbmBcblxuY29uc3QgYmxvb21QcmVmaWx0ZXJTaGFkZXIgPSBjb21waWxlU2hhZGVyKFxuICBnbC5GUkFHTUVOVF9TSEFERVIsXG4gIGBcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBzYW1wbGVyMkQ7XG5cbiAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xuICAgIHVuaWZvcm0gdmVjMyBjdXJ2ZTtcbiAgICB1bmlmb3JtIGZsb2F0IHRocmVzaG9sZDtcblxuICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgIHZlYzMgYyA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlV2KS5yZ2I7XG4gICAgICAgIGZsb2F0IGJyID0gbWF4KGMuciwgbWF4KGMuZywgYy5iKSk7XG4gICAgICAgIGZsb2F0IHJxID0gY2xhbXAoYnIgLSBjdXJ2ZS54LCAwLjAsIGN1cnZlLnkpO1xuICAgICAgICBycSA9IGN1cnZlLnogKiBycSAqIHJxO1xuICAgICAgICBjICo9IG1heChycSwgYnIgLSB0aHJlc2hvbGQpIC8gbWF4KGJyLCAwLjAwMDEpO1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGMsIDAuMCk7XG4gICAgfVxuYFxuKVxuXG5jb25zdCBibG9vbUJsdXJTaGFkZXIgPSBjb21waWxlU2hhZGVyKFxuICBnbC5GUkFHTUVOVF9TSEFERVIsXG4gIGBcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBzYW1wbGVyMkQ7XG5cbiAgICB2YXJ5aW5nIHZlYzIgdkw7XG4gICAgdmFyeWluZyB2ZWMyIHZSO1xuICAgIHZhcnlpbmcgdmVjMiB2VDtcbiAgICB2YXJ5aW5nIHZlYzIgdkI7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XG5cbiAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICB2ZWM0IHN1bSA9IHZlYzQoMC4wKTtcbiAgICAgICAgc3VtICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdkwpO1xuICAgICAgICBzdW0gKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2Uik7XG4gICAgICAgIHN1bSArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUKTtcbiAgICAgICAgc3VtICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdkIpO1xuICAgICAgICBzdW0gKj0gMC4yNTtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gc3VtO1xuICAgIH1cbmBcbilcblxuY29uc3QgYmxvb21GaW5hbFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gIGdsLkZSQUdNRU5UX1NIQURFUixcbiAgYFxuICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgIHByZWNpc2lvbiBtZWRpdW1wIHNhbXBsZXIyRDtcblxuICAgIHZhcnlpbmcgdmVjMiB2TDtcbiAgICB2YXJ5aW5nIHZlYzIgdlI7XG4gICAgdmFyeWluZyB2ZWMyIHZUO1xuICAgIHZhcnlpbmcgdmVjMiB2QjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcbiAgICB1bmlmb3JtIGZsb2F0IGludGVuc2l0eTtcblxuICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgIHZlYzQgc3VtID0gdmVjNCgwLjApO1xuICAgICAgICBzdW0gKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2TCk7XG4gICAgICAgIHN1bSArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZSKTtcbiAgICAgICAgc3VtICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlQpO1xuICAgICAgICBzdW0gKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2Qik7XG4gICAgICAgIHN1bSAqPSAwLjI1O1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSBzdW0gKiBpbnRlbnNpdHk7XG4gICAgfVxuYFxuKVxuXG5jb25zdCBzdW5yYXlzTWFza1NoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gIGdsLkZSQUdNRU5UX1NIQURFUixcbiAgYFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICBwcmVjaXNpb24gaGlnaHAgc2FtcGxlcjJEO1xuXG4gICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcblxuICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgIHZlYzQgYyA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlV2KTtcbiAgICAgICAgZmxvYXQgYnIgPSBtYXgoYy5yLCBtYXgoYy5nLCBjLmIpKTtcbiAgICAgICAgYy5hID0gMS4wIC0gbWluKG1heChiciAqIDIwLjAsIDAuMCksIDAuOCk7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IGM7XG4gICAgfVxuYFxuKVxuXG5jb25zdCBzdW5yYXlzU2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgZ2wuRlJBR01FTlRfU0hBREVSLFxuICBgXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgIHByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7XG5cbiAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xuICAgIHVuaWZvcm0gZmxvYXQgd2VpZ2h0O1xuXG4gICAgI2RlZmluZSBJVEVSQVRJT05TIDE2XG5cbiAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICBmbG9hdCBEZW5zaXR5ID0gMC4zO1xuICAgICAgICBmbG9hdCBEZWNheSA9IDAuOTU7XG4gICAgICAgIGZsb2F0IEV4cG9zdXJlID0gMC43O1xuXG4gICAgICAgIHZlYzIgY29vcmQgPSB2VXY7XG4gICAgICAgIHZlYzIgZGlyID0gdlV2IC0gMC41O1xuXG4gICAgICAgIGRpciAqPSAxLjAgLyBmbG9hdChJVEVSQVRJT05TKSAqIERlbnNpdHk7XG4gICAgICAgIGZsb2F0IGlsbHVtaW5hdGlvbkRlY2F5ID0gMS4wO1xuXG4gICAgICAgIGZsb2F0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VXYpLmE7XG5cbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBJVEVSQVRJT05TOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvb3JkIC09IGRpcjtcbiAgICAgICAgICAgIGZsb2F0IGNvbCA9IHRleHR1cmUyRCh1VGV4dHVyZSwgY29vcmQpLmE7XG4gICAgICAgICAgICBjb2xvciArPSBjb2wgKiBpbGx1bWluYXRpb25EZWNheSAqIHdlaWdodDtcbiAgICAgICAgICAgIGlsbHVtaW5hdGlvbkRlY2F5ICo9IERlY2F5O1xuICAgICAgICB9XG5cbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciAqIEV4cG9zdXJlLCAwLjAsIDAuMCwgMS4wKTtcbiAgICB9XG5gXG4pXG5cbmNvbnN0IHNwbGF0U2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgZ2wuRlJBR01FTlRfU0hBREVSLFxuICBgXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgIHByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7XG5cbiAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVUYXJnZXQ7XG4gICAgdW5pZm9ybSBmbG9hdCBhc3BlY3RSYXRpbztcbiAgICB1bmlmb3JtIHZlYzMgY29sb3I7XG4gICAgdW5pZm9ybSB2ZWMyIHBvaW50O1xuICAgIHVuaWZvcm0gZmxvYXQgcmFkaXVzO1xuXG4gICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgdmVjMiBwID0gdlV2IC0gcG9pbnQueHk7XG4gICAgICAgIHAueCAqPSBhc3BlY3RSYXRpbztcbiAgICAgICAgdmVjMyBzcGxhdCA9IGV4cCgtZG90KHAsIHApIC8gcmFkaXVzKSAqIGNvbG9yO1xuICAgICAgICB2ZWMzIGJhc2UgPSB0ZXh0dXJlMkQodVRhcmdldCwgdlV2KS54eXo7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoYmFzZSArIHNwbGF0LCAxLjApO1xuICAgIH1cbmBcbilcblxuY29uc3QgYWR2ZWN0aW9uU2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgZ2wuRlJBR01FTlRfU0hBREVSLFxuICBgXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgIHByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7XG5cbiAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVWZWxvY2l0eTtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U291cmNlO1xuICAgIHVuaWZvcm0gdmVjMiB0ZXhlbFNpemU7XG4gICAgdW5pZm9ybSB2ZWMyIGR5ZVRleGVsU2l6ZTtcbiAgICB1bmlmb3JtIGZsb2F0IGR0O1xuICAgIHVuaWZvcm0gZmxvYXQgZGlzc2lwYXRpb247XG5cbiAgICB2ZWM0IGJpbGVycCAoc2FtcGxlcjJEIHNhbSwgdmVjMiB1diwgdmVjMiB0c2l6ZSkge1xuICAgICAgICB2ZWMyIHN0ID0gdXYgLyB0c2l6ZSAtIDAuNTtcblxuICAgICAgICB2ZWMyIGl1diA9IGZsb29yKHN0KTtcbiAgICAgICAgdmVjMiBmdXYgPSBmcmFjdChzdCk7XG5cbiAgICAgICAgdmVjNCBhID0gdGV4dHVyZTJEKHNhbSwgKGl1diArIHZlYzIoMC41LCAwLjUpKSAqIHRzaXplKTtcbiAgICAgICAgdmVjNCBiID0gdGV4dHVyZTJEKHNhbSwgKGl1diArIHZlYzIoMS41LCAwLjUpKSAqIHRzaXplKTtcbiAgICAgICAgdmVjNCBjID0gdGV4dHVyZTJEKHNhbSwgKGl1diArIHZlYzIoMC41LCAxLjUpKSAqIHRzaXplKTtcbiAgICAgICAgdmVjNCBkID0gdGV4dHVyZTJEKHNhbSwgKGl1diArIHZlYzIoMS41LCAxLjUpKSAqIHRzaXplKTtcblxuICAgICAgICByZXR1cm4gbWl4KG1peChhLCBiLCBmdXYueCksIG1peChjLCBkLCBmdXYueCksIGZ1di55KTtcbiAgICB9XG5cbiAgICB2b2lkIG1haW4gKCkge1xuICAgICNpZmRlZiBNQU5VQUxfRklMVEVSSU5HXG4gICAgICAgIHZlYzIgY29vcmQgPSB2VXYgLSBkdCAqIGJpbGVycCh1VmVsb2NpdHksIHZVdiwgdGV4ZWxTaXplKS54eSAqIHRleGVsU2l6ZTtcbiAgICAgICAgdmVjNCByZXN1bHQgPSBiaWxlcnAodVNvdXJjZSwgY29vcmQsIGR5ZVRleGVsU2l6ZSk7XG4gICAgI2Vsc2VcbiAgICAgICAgdmVjMiBjb29yZCA9IHZVdiAtIGR0ICogdGV4dHVyZTJEKHVWZWxvY2l0eSwgdlV2KS54eSAqIHRleGVsU2l6ZTtcbiAgICAgICAgdmVjNCByZXN1bHQgPSB0ZXh0dXJlMkQodVNvdXJjZSwgY29vcmQpO1xuICAgICNlbmRpZlxuICAgICAgICBmbG9hdCBkZWNheSA9IDEuMCArIGRpc3NpcGF0aW9uICogZHQ7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHJlc3VsdCAvIGRlY2F5O1xuICAgIH1gLFxuICBleHQuc3VwcG9ydExpbmVhckZpbHRlcmluZyA/IHVuZGVmaW5lZCA6IFsnTUFOVUFMX0ZJTFRFUklORyddXG4pXG5cbmNvbnN0IGRpdmVyZ2VuY2VTaGFkZXIgPSBjb21waWxlU2hhZGVyKFxuICBnbC5GUkFHTUVOVF9TSEFERVIsXG4gIGBcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBzYW1wbGVyMkQ7XG5cbiAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlV2O1xuICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2TDtcbiAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlI7XG4gICAgdmFyeWluZyBoaWdocCB2ZWMyIHZUO1xuICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2QjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VmVsb2NpdHk7XG5cbiAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICBmbG9hdCBMID0gdGV4dHVyZTJEKHVWZWxvY2l0eSwgdkwpLng7XG4gICAgICAgIGZsb2F0IFIgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2UikueDtcbiAgICAgICAgZmxvYXQgVCA9IHRleHR1cmUyRCh1VmVsb2NpdHksIHZUKS55O1xuICAgICAgICBmbG9hdCBCID0gdGV4dHVyZTJEKHVWZWxvY2l0eSwgdkIpLnk7XG5cbiAgICAgICAgdmVjMiBDID0gdGV4dHVyZTJEKHVWZWxvY2l0eSwgdlV2KS54eTtcbiAgICAgICAgaWYgKHZMLnggPCAwLjApIHsgTCA9IC1DLng7IH1cbiAgICAgICAgaWYgKHZSLnggPiAxLjApIHsgUiA9IC1DLng7IH1cbiAgICAgICAgaWYgKHZULnkgPiAxLjApIHsgVCA9IC1DLnk7IH1cbiAgICAgICAgaWYgKHZCLnkgPCAwLjApIHsgQiA9IC1DLnk7IH1cblxuICAgICAgICBmbG9hdCBkaXYgPSAwLjUgKiAoUiAtIEwgKyBUIC0gQik7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoZGl2LCAwLjAsIDAuMCwgMS4wKTtcbiAgICB9XG5gXG4pXG5cbmNvbnN0IGN1cmxTaGFkZXIgPSBjb21waWxlU2hhZGVyKFxuICBnbC5GUkFHTUVOVF9TSEFERVIsXG4gIGBcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBzYW1wbGVyMkQ7XG5cbiAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlV2O1xuICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2TDtcbiAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlI7XG4gICAgdmFyeWluZyBoaWdocCB2ZWMyIHZUO1xuICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2QjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VmVsb2NpdHk7XG5cbiAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICBmbG9hdCBMID0gdGV4dHVyZTJEKHVWZWxvY2l0eSwgdkwpLnk7XG4gICAgICAgIGZsb2F0IFIgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2UikueTtcbiAgICAgICAgZmxvYXQgVCA9IHRleHR1cmUyRCh1VmVsb2NpdHksIHZUKS54O1xuICAgICAgICBmbG9hdCBCID0gdGV4dHVyZTJEKHVWZWxvY2l0eSwgdkIpLng7XG4gICAgICAgIGZsb2F0IHZvcnRpY2l0eSA9IFIgLSBMIC0gVCArIEI7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC41ICogdm9ydGljaXR5LCAwLjAsIDAuMCwgMS4wKTtcbiAgICB9XG5gXG4pXG5cbmNvbnN0IHZvcnRpY2l0eVNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gIGdsLkZSQUdNRU5UX1NIQURFUixcbiAgYFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICBwcmVjaXNpb24gaGlnaHAgc2FtcGxlcjJEO1xuXG4gICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICB2YXJ5aW5nIHZlYzIgdkw7XG4gICAgdmFyeWluZyB2ZWMyIHZSO1xuICAgIHZhcnlpbmcgdmVjMiB2VDtcbiAgICB2YXJ5aW5nIHZlYzIgdkI7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVZlbG9jaXR5O1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVDdXJsO1xuICAgIHVuaWZvcm0gZmxvYXQgY3VybDtcbiAgICB1bmlmb3JtIGZsb2F0IGR0O1xuXG4gICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgZmxvYXQgTCA9IHRleHR1cmUyRCh1Q3VybCwgdkwpLng7XG4gICAgICAgIGZsb2F0IFIgPSB0ZXh0dXJlMkQodUN1cmwsIHZSKS54O1xuICAgICAgICBmbG9hdCBUID0gdGV4dHVyZTJEKHVDdXJsLCB2VCkueDtcbiAgICAgICAgZmxvYXQgQiA9IHRleHR1cmUyRCh1Q3VybCwgdkIpLng7XG4gICAgICAgIGZsb2F0IEMgPSB0ZXh0dXJlMkQodUN1cmwsIHZVdikueDtcblxuICAgICAgICB2ZWMyIGZvcmNlID0gMC41ICogdmVjMihhYnMoVCkgLSBhYnMoQiksIGFicyhSKSAtIGFicyhMKSk7XG4gICAgICAgIGZvcmNlIC89IGxlbmd0aChmb3JjZSkgKyAwLjAwMDE7XG4gICAgICAgIGZvcmNlICo9IGN1cmwgKiBDO1xuICAgICAgICBmb3JjZS55ICo9IC0xLjA7XG5cbiAgICAgICAgdmVjMiB2ZWwgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2VXYpLnh5O1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZlbCArIGZvcmNlICogZHQsIDAuMCwgMS4wKTtcbiAgICB9XG5gXG4pXG5cbmNvbnN0IHByZXNzdXJlU2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgZ2wuRlJBR01FTlRfU0hBREVSLFxuICBgXG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgc2FtcGxlcjJEO1xuXG4gICAgdmFyeWluZyBoaWdocCB2ZWMyIHZVdjtcbiAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdkw7XG4gICAgdmFyeWluZyBoaWdocCB2ZWMyIHZSO1xuICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2VDtcbiAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdkI7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVByZXNzdXJlO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVEaXZlcmdlbmNlO1xuXG4gICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgZmxvYXQgTCA9IHRleHR1cmUyRCh1UHJlc3N1cmUsIHZMKS54O1xuICAgICAgICBmbG9hdCBSID0gdGV4dHVyZTJEKHVQcmVzc3VyZSwgdlIpLng7XG4gICAgICAgIGZsb2F0IFQgPSB0ZXh0dXJlMkQodVByZXNzdXJlLCB2VCkueDtcbiAgICAgICAgZmxvYXQgQiA9IHRleHR1cmUyRCh1UHJlc3N1cmUsIHZCKS54O1xuICAgICAgICBmbG9hdCBDID0gdGV4dHVyZTJEKHVQcmVzc3VyZSwgdlV2KS54O1xuICAgICAgICBmbG9hdCBkaXZlcmdlbmNlID0gdGV4dHVyZTJEKHVEaXZlcmdlbmNlLCB2VXYpLng7XG4gICAgICAgIGZsb2F0IHByZXNzdXJlID0gKEwgKyBSICsgQiArIFQgLSBkaXZlcmdlbmNlKSAqIDAuMjU7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQocHJlc3N1cmUsIDAuMCwgMC4wLCAxLjApO1xuICAgIH1cbmBcbilcblxuY29uc3QgZ3JhZGllbnRTdWJ0cmFjdFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gIGdsLkZSQUdNRU5UX1NIQURFUixcbiAgYFxuICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgIHByZWNpc2lvbiBtZWRpdW1wIHNhbXBsZXIyRDtcblxuICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2VXY7XG4gICAgdmFyeWluZyBoaWdocCB2ZWMyIHZMO1xuICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2UjtcbiAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlQ7XG4gICAgdmFyeWluZyBoaWdocCB2ZWMyIHZCO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVQcmVzc3VyZTtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VmVsb2NpdHk7XG5cbiAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICBmbG9hdCBMID0gdGV4dHVyZTJEKHVQcmVzc3VyZSwgdkwpLng7XG4gICAgICAgIGZsb2F0IFIgPSB0ZXh0dXJlMkQodVByZXNzdXJlLCB2UikueDtcbiAgICAgICAgZmxvYXQgVCA9IHRleHR1cmUyRCh1UHJlc3N1cmUsIHZUKS54O1xuICAgICAgICBmbG9hdCBCID0gdGV4dHVyZTJEKHVQcmVzc3VyZSwgdkIpLng7XG4gICAgICAgIHZlYzIgdmVsb2NpdHkgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2VXYpLnh5O1xuICAgICAgICB2ZWxvY2l0eS54eSAtPSB2ZWMyKFIgLSBMLCBUIC0gQik7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodmVsb2NpdHksIDAuMCwgMS4wKTtcbiAgICB9XG5gXG4pXG5cbmNvbnN0IGJsaXQgPSAoKCkgPT4ge1xuICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgZ2wuY3JlYXRlQnVmZmVyKCkpXG4gIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KFstMSwgLTEsIC0xLCAxLCAxLCAxLCAxLCAtMV0pLCBnbC5TVEFUSUNfRFJBVylcbiAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZ2wuY3JlYXRlQnVmZmVyKCkpXG4gIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG5ldyBVaW50MTZBcnJheShbMCwgMSwgMiwgMCwgMiwgM10pLCBnbC5TVEFUSUNfRFJBVylcbiAgZ2wudmVydGV4QXR0cmliUG9pbnRlcigwLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApXG4gIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KDApXG5cbiAgcmV0dXJuIChkZXN0aW5hdGlvbjogV2ViR0xGcmFtZWJ1ZmZlciB8IG51bGwpID0+IHtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGRlc3RpbmF0aW9uKVxuICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwKVxuICB9XG59KSgpXG5cbmxldCBkeWU6IERvdWJsZUZCT1xubGV0IHZlbG9jaXR5OiBEb3VibGVGQk9cbmxldCBkaXZlcmdlbmNlOiBGQk9cbmxldCBjdXJsOiBGQk9cbmxldCBwcmVzc3VyZTogRG91YmxlRkJPXG5sZXQgYmxvb206IEZCT1xubGV0IGJsb29tRnJhbWVidWZmZXJzOiBGQk9bXSA9IFtdXG5sZXQgc3VucmF5czogRkJPXG5sZXQgc3VucmF5c1RlbXA6IEZCT1xuXG5sZXQgZGl0aGVyaW5nVGV4dHVyZTogVGV4dHVyZSA9IGNyZWF0ZVRleHR1cmVBc3luYygnTERSX0xMTDFfMC5wbmcnKVxuXG5jb25zdCBibHVyUHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGJsdXJWZXJ0ZXhTaGFkZXIsIGJsdXJTaGFkZXIpXG5jb25zdCBjb3B5UHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGJhc2VWZXJ0ZXhTaGFkZXIsIGNvcHlTaGFkZXIpXG5jb25zdCBjbGVhclByb2dyYW0gPSBuZXcgUHJvZ3JhbShiYXNlVmVydGV4U2hhZGVyLCBjbGVhclNoYWRlcilcbmNvbnN0IGNvbG9yUHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGJhc2VWZXJ0ZXhTaGFkZXIsIGNvbG9yU2hhZGVyKVxuY29uc3QgY2hlY2tlcmJvYXJkUHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGJhc2VWZXJ0ZXhTaGFkZXIsIGNoZWNrZXJib2FyZFNoYWRlcilcbmNvbnN0IGJsb29tUHJlZmlsdGVyUHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGJhc2VWZXJ0ZXhTaGFkZXIsIGJsb29tUHJlZmlsdGVyU2hhZGVyKVxuY29uc3QgYmxvb21CbHVyUHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGJhc2VWZXJ0ZXhTaGFkZXIsIGJsb29tQmx1clNoYWRlcilcbmNvbnN0IGJsb29tRmluYWxQcm9ncmFtID0gbmV3IFByb2dyYW0oYmFzZVZlcnRleFNoYWRlciwgYmxvb21GaW5hbFNoYWRlcilcbmNvbnN0IHN1bnJheXNNYXNrUHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGJhc2VWZXJ0ZXhTaGFkZXIsIHN1bnJheXNNYXNrU2hhZGVyKVxuY29uc3Qgc3VucmF5c1Byb2dyYW0gPSBuZXcgUHJvZ3JhbShiYXNlVmVydGV4U2hhZGVyLCBzdW5yYXlzU2hhZGVyKVxuY29uc3Qgc3BsYXRQcm9ncmFtID0gbmV3IFByb2dyYW0oYmFzZVZlcnRleFNoYWRlciwgc3BsYXRTaGFkZXIpXG5jb25zdCBhZHZlY3Rpb25Qcm9ncmFtID0gbmV3IFByb2dyYW0oYmFzZVZlcnRleFNoYWRlciwgYWR2ZWN0aW9uU2hhZGVyKVxuY29uc3QgZGl2ZXJnZW5jZVByb2dyYW0gPSBuZXcgUHJvZ3JhbShiYXNlVmVydGV4U2hhZGVyLCBkaXZlcmdlbmNlU2hhZGVyKVxuY29uc3QgY3VybFByb2dyYW0gPSBuZXcgUHJvZ3JhbShiYXNlVmVydGV4U2hhZGVyLCBjdXJsU2hhZGVyKVxuY29uc3Qgdm9ydGljaXR5UHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGJhc2VWZXJ0ZXhTaGFkZXIsIHZvcnRpY2l0eVNoYWRlcilcbmNvbnN0IHByZXNzdXJlUHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGJhc2VWZXJ0ZXhTaGFkZXIsIHByZXNzdXJlU2hhZGVyKVxuY29uc3QgZ3JhZGllblN1YnRyYWN0UHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGJhc2VWZXJ0ZXhTaGFkZXIsIGdyYWRpZW50U3VidHJhY3RTaGFkZXIpXG5cbmNvbnN0IGRpc3BsYXlNYXRlcmlhbCA9IG5ldyBNYXRlcmlhbChiYXNlVmVydGV4U2hhZGVyLCBkaXNwbGF5U2hhZGVyU291cmNlKVxuXG5mdW5jdGlvbiBpbml0RnJhbWVidWZmZXJzKCkge1xuICBsZXQgc2ltUmVzID0gZ2V0UmVzb2x1dGlvbihjb25maWcuU0lNX1JFU09MVVRJT04pXG4gIGxldCBkeWVSZXMgPSBnZXRSZXNvbHV0aW9uKGNvbmZpZy5EWUVfUkVTT0xVVElPTilcblxuICBjb25zdCB0ZXhUeXBlID0gZXh0LmhhbGZGbG9hdFRleFR5cGVcbiAgY29uc3QgcmdiYSA9IGV4dC5mb3JtYXRSR0JBXG4gIGNvbnN0IHJnID0gZXh0LmZvcm1hdFJHXG4gIGNvbnN0IHIgPSBleHQuZm9ybWF0UlxuICBjb25zdCBmaWx0ZXJpbmcgPSBleHQuc3VwcG9ydExpbmVhckZpbHRlcmluZyA/IGdsLkxJTkVBUiA6IGdsLk5FQVJFU1RcblxuICBpZiAoZHllID09IG51bGwpXG4gICAgZHllID0gY3JlYXRlRG91YmxlRkJPKFxuICAgICAgZHllUmVzLndpZHRoLFxuICAgICAgZHllUmVzLmhlaWdodCxcbiAgICAgIHJnYmEuaW50ZXJuYWxGb3JtYXQsXG4gICAgICByZ2JhLmZvcm1hdCxcbiAgICAgIHRleFR5cGUsXG4gICAgICBmaWx0ZXJpbmdcbiAgICApXG4gIGVsc2VcbiAgICBkeWUgPSByZXNpemVEb3VibGVGQk8oXG4gICAgICBkeWUsXG4gICAgICBkeWVSZXMud2lkdGgsXG4gICAgICBkeWVSZXMuaGVpZ2h0LFxuICAgICAgcmdiYS5pbnRlcm5hbEZvcm1hdCxcbiAgICAgIHJnYmEuZm9ybWF0LFxuICAgICAgdGV4VHlwZSxcbiAgICAgIGZpbHRlcmluZ1xuICAgIClcblxuICBpZiAodmVsb2NpdHkgPT0gbnVsbClcbiAgICB2ZWxvY2l0eSA9IGNyZWF0ZURvdWJsZUZCTyhcbiAgICAgIHNpbVJlcy53aWR0aCxcbiAgICAgIHNpbVJlcy5oZWlnaHQsXG4gICAgICByZy5pbnRlcm5hbEZvcm1hdCxcbiAgICAgIHJnLmZvcm1hdCxcbiAgICAgIHRleFR5cGUsXG4gICAgICBmaWx0ZXJpbmdcbiAgICApXG4gIGVsc2VcbiAgICB2ZWxvY2l0eSA9IHJlc2l6ZURvdWJsZUZCTyhcbiAgICAgIHZlbG9jaXR5LFxuICAgICAgc2ltUmVzLndpZHRoLFxuICAgICAgc2ltUmVzLmhlaWdodCxcbiAgICAgIHJnLmludGVybmFsRm9ybWF0LFxuICAgICAgcmcuZm9ybWF0LFxuICAgICAgdGV4VHlwZSxcbiAgICAgIGZpbHRlcmluZ1xuICAgIClcblxuICBkaXZlcmdlbmNlID0gY3JlYXRlRkJPKFxuICAgIHNpbVJlcy53aWR0aCxcbiAgICBzaW1SZXMuaGVpZ2h0LFxuICAgIHIuaW50ZXJuYWxGb3JtYXQsXG4gICAgci5mb3JtYXQsXG4gICAgdGV4VHlwZSxcbiAgICBnbC5ORUFSRVNUXG4gIClcbiAgY3VybCA9IGNyZWF0ZUZCTyhzaW1SZXMud2lkdGgsIHNpbVJlcy5oZWlnaHQsIHIuaW50ZXJuYWxGb3JtYXQsIHIuZm9ybWF0LCB0ZXhUeXBlLCBnbC5ORUFSRVNUKVxuICBwcmVzc3VyZSA9IGNyZWF0ZURvdWJsZUZCTyhcbiAgICBzaW1SZXMud2lkdGgsXG4gICAgc2ltUmVzLmhlaWdodCxcbiAgICByLmludGVybmFsRm9ybWF0LFxuICAgIHIuZm9ybWF0LFxuICAgIHRleFR5cGUsXG4gICAgZ2wuTkVBUkVTVFxuICApXG5cbiAgaW5pdEJsb29tRnJhbWVidWZmZXJzKClcbiAgaW5pdFN1bnJheXNGcmFtZWJ1ZmZlcnMoKVxufVxuXG5mdW5jdGlvbiBpbml0Qmxvb21GcmFtZWJ1ZmZlcnMoKSB7XG4gIGxldCByZXMgPSBnZXRSZXNvbHV0aW9uKGNvbmZpZy5CTE9PTV9SRVNPTFVUSU9OKVxuXG4gIGNvbnN0IHRleFR5cGUgPSBleHQuaGFsZkZsb2F0VGV4VHlwZVxuICBjb25zdCByZ2JhID0gZXh0LmZvcm1hdFJHQkFcbiAgY29uc3QgZmlsdGVyaW5nID0gZXh0LnN1cHBvcnRMaW5lYXJGaWx0ZXJpbmcgPyBnbC5MSU5FQVIgOiBnbC5ORUFSRVNUXG5cbiAgYmxvb20gPSBjcmVhdGVGQk8ocmVzLndpZHRoLCByZXMuaGVpZ2h0LCByZ2JhLmludGVybmFsRm9ybWF0LCByZ2JhLmZvcm1hdCwgdGV4VHlwZSwgZmlsdGVyaW5nKVxuXG4gIGJsb29tRnJhbWVidWZmZXJzLmxlbmd0aCA9IDBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb25maWcuQkxPT01fSVRFUkFUSU9OUzsgaSsrKSB7XG4gICAgbGV0IHdpZHRoID0gcmVzLndpZHRoID4+IChpICsgMSlcbiAgICBsZXQgaGVpZ2h0ID0gcmVzLmhlaWdodCA+PiAoaSArIDEpXG5cbiAgICBpZiAod2lkdGggPCAyIHx8IGhlaWdodCA8IDIpIGJyZWFrXG5cbiAgICBsZXQgZmJvID0gY3JlYXRlRkJPKHdpZHRoLCBoZWlnaHQsIHJnYmEuaW50ZXJuYWxGb3JtYXQsIHJnYmEuZm9ybWF0LCB0ZXhUeXBlLCBmaWx0ZXJpbmcpXG4gICAgYmxvb21GcmFtZWJ1ZmZlcnMucHVzaChmYm8pXG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFN1bnJheXNGcmFtZWJ1ZmZlcnMoKSB7XG4gIGxldCByZXMgPSBnZXRSZXNvbHV0aW9uKGNvbmZpZy5TVU5SQVlTX1JFU09MVVRJT04pXG5cbiAgY29uc3QgdGV4VHlwZSA9IGV4dC5oYWxmRmxvYXRUZXhUeXBlXG4gIGNvbnN0IHIgPSBleHQuZm9ybWF0UlxuICBjb25zdCBmaWx0ZXJpbmcgPSBleHQuc3VwcG9ydExpbmVhckZpbHRlcmluZyA/IGdsLkxJTkVBUiA6IGdsLk5FQVJFU1RcblxuICBzdW5yYXlzID0gY3JlYXRlRkJPKHJlcy53aWR0aCwgcmVzLmhlaWdodCwgci5pbnRlcm5hbEZvcm1hdCwgci5mb3JtYXQsIHRleFR5cGUsIGZpbHRlcmluZylcbiAgc3VucmF5c1RlbXAgPSBjcmVhdGVGQk8ocmVzLndpZHRoLCByZXMuaGVpZ2h0LCByLmludGVybmFsRm9ybWF0LCByLmZvcm1hdCwgdGV4VHlwZSwgZmlsdGVyaW5nKVxufVxuXG50eXBlIEZCTyA9IFJldHVyblR5cGU8dHlwZW9mIGNyZWF0ZUZCTz5cblxuZnVuY3Rpb24gY3JlYXRlRkJPKFxuICB3OiBudW1iZXIsXG4gIGg6IG51bWJlcixcbiAgaW50ZXJuYWxGb3JtYXQ6IG51bWJlcixcbiAgZm9ybWF0OiBudW1iZXIsXG4gIHR5cGU6IG51bWJlcixcbiAgcGFyYW06IG51bWJlclxuKSB7XG4gIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApXG4gIGxldCB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpXG4gIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpXG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBwYXJhbSlcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIHBhcmFtKVxuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKVxuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKVxuICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGludGVybmFsRm9ybWF0LCB3LCBoLCAwLCBmb3JtYXQsIHR5cGUsIG51bGwpXG5cbiAgbGV0IGZibyA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKClcbiAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmYm8pXG4gIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgMClcbiAgZ2wudmlld3BvcnQoMCwgMCwgdywgaClcbiAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVClcblxuICBsZXQgdGV4ZWxTaXplWCA9IDEuMCAvIHdcbiAgbGV0IHRleGVsU2l6ZVkgPSAxLjAgLyBoXG5cbiAgcmV0dXJuIHtcbiAgICB0ZXh0dXJlLFxuICAgIGZibyxcbiAgICB3aWR0aDogdyxcbiAgICBoZWlnaHQ6IGgsXG4gICAgdGV4ZWxTaXplWCxcbiAgICB0ZXhlbFNpemVZLFxuICAgIGF0dGFjaChpZDogbnVtYmVyKSB7XG4gICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgaWQpXG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKVxuICAgICAgcmV0dXJuIGlkXG4gICAgfSxcbiAgfVxufVxuXG50eXBlIERvdWJsZUZCTyA9IFJldHVyblR5cGU8dHlwZW9mIGNyZWF0ZURvdWJsZUZCTz5cblxuZnVuY3Rpb24gY3JlYXRlRG91YmxlRkJPKFxuICB3OiBudW1iZXIsXG4gIGg6IG51bWJlcixcbiAgaW50ZXJuYWxGb3JtYXQ6IG51bWJlcixcbiAgZm9ybWF0OiBudW1iZXIsXG4gIHR5cGU6IG51bWJlcixcbiAgcGFyYW06IG51bWJlclxuKSB7XG4gIGxldCBmYm8xOiBGQk8gPSBjcmVhdGVGQk8odywgaCwgaW50ZXJuYWxGb3JtYXQsIGZvcm1hdCwgdHlwZSwgcGFyYW0pXG4gIGxldCBmYm8yOiBGQk8gPSBjcmVhdGVGQk8odywgaCwgaW50ZXJuYWxGb3JtYXQsIGZvcm1hdCwgdHlwZSwgcGFyYW0pXG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogdyxcbiAgICBoZWlnaHQ6IGgsXG4gICAgdGV4ZWxTaXplWDogZmJvMS50ZXhlbFNpemVYLFxuICAgIHRleGVsU2l6ZVk6IGZibzEudGV4ZWxTaXplWSxcbiAgICBnZXQgcmVhZCgpOiBGQk8ge1xuICAgICAgcmV0dXJuIGZibzFcbiAgICB9LFxuICAgIHNldCByZWFkKHZhbHVlOiBGQk8pIHtcbiAgICAgIGZibzEgPSB2YWx1ZVxuICAgIH0sXG4gICAgZ2V0IHdyaXRlKCk6IEZCTyB7XG4gICAgICByZXR1cm4gZmJvMlxuICAgIH0sXG4gICAgc2V0IHdyaXRlKHZhbHVlOiBGQk8pIHtcbiAgICAgIGZibzIgPSB2YWx1ZVxuICAgIH0sXG4gICAgc3dhcCgpIHtcbiAgICAgIGxldCB0ZW1wID0gZmJvMVxuICAgICAgZmJvMSA9IGZibzJcbiAgICAgIGZibzIgPSB0ZW1wXG4gICAgfSxcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNpemVGQk8oXG4gIHRhcmdldDogRkJPLFxuICB3OiBudW1iZXIsXG4gIGg6IG51bWJlcixcbiAgaW50ZXJuYWxGb3JtYXQ6IG51bWJlcixcbiAgZm9ybWF0OiBudW1iZXIsXG4gIHR5cGU6IG51bWJlcixcbiAgcGFyYW06IG51bWJlclxuKSB7XG4gIGxldCBuZXdGQk8gPSBjcmVhdGVGQk8odywgaCwgaW50ZXJuYWxGb3JtYXQsIGZvcm1hdCwgdHlwZSwgcGFyYW0pXG4gIGNvcHlQcm9ncmFtLmJpbmQoKVxuICBnbC51bmlmb3JtMWkoY29weVByb2dyYW0udW5pZm9ybXMudVRleHR1cmUsIHRhcmdldC5hdHRhY2goMCkpXG4gIGJsaXQobmV3RkJPLmZibylcbiAgcmV0dXJuIG5ld0ZCT1xufVxuXG5mdW5jdGlvbiByZXNpemVEb3VibGVGQk8oXG4gIHRhcmdldDogRG91YmxlRkJPLFxuICB3OiBudW1iZXIsXG4gIGg6IG51bWJlcixcbiAgaW50ZXJuYWxGb3JtYXQ6IG51bWJlcixcbiAgZm9ybWF0OiBudW1iZXIsXG4gIHR5cGU6IG51bWJlcixcbiAgcGFyYW06IG51bWJlclxuKSB7XG4gIGlmICh0YXJnZXQud2lkdGggPT0gdyAmJiB0YXJnZXQuaGVpZ2h0ID09IGgpIHJldHVybiB0YXJnZXRcbiAgdGFyZ2V0LnJlYWQgPSByZXNpemVGQk8odGFyZ2V0LnJlYWQsIHcsIGgsIGludGVybmFsRm9ybWF0LCBmb3JtYXQsIHR5cGUsIHBhcmFtKVxuICB0YXJnZXQud3JpdGUgPSBjcmVhdGVGQk8odywgaCwgaW50ZXJuYWxGb3JtYXQsIGZvcm1hdCwgdHlwZSwgcGFyYW0pXG4gIHRhcmdldC53aWR0aCA9IHdcbiAgdGFyZ2V0LmhlaWdodCA9IGhcbiAgdGFyZ2V0LnRleGVsU2l6ZVggPSAxLjAgLyB3XG4gIHRhcmdldC50ZXhlbFNpemVZID0gMS4wIC8gaFxuICByZXR1cm4gdGFyZ2V0XG59XG5cbnR5cGUgVGV4dHVyZSA9IFJldHVyblR5cGU8dHlwZW9mIGNyZWF0ZVRleHR1cmVBc3luYz5cblxuZnVuY3Rpb24gY3JlYXRlVGV4dHVyZUFzeW5jKHVybDogc3RyaW5nKSB7XG4gIGxldCB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpXG4gIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpXG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpXG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpXG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLlJFUEVBVClcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuUkVQRUFUKVxuICBnbC50ZXhJbWFnZTJEKFxuICAgIGdsLlRFWFRVUkVfMkQsXG4gICAgMCxcbiAgICBnbC5SR0IsXG4gICAgMSxcbiAgICAxLFxuICAgIDAsXG4gICAgZ2wuUkdCLFxuICAgIGdsLlVOU0lHTkVEX0JZVEUsXG4gICAgbmV3IFVpbnQ4QXJyYXkoWzI1NSwgMjU1LCAyNTVdKVxuICApXG5cbiAgbGV0IG9iaiA9IHtcbiAgICB0ZXh0dXJlLFxuICAgIHdpZHRoOiAxLFxuICAgIGhlaWdodDogMSxcbiAgICBhdHRhY2goaWQ6IG51bWJlcikge1xuICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGlkKVxuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSlcbiAgICAgIHJldHVybiBpZFxuICAgIH0sXG4gIH1cblxuICBsZXQgaW1hZ2UgPSBuZXcgSW1hZ2UoKVxuICAvL2ltYWdlLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cydcbiAgaW1hZ2Uub25sb2FkID0gKCkgPT4ge1xuICAgIG9iai53aWR0aCA9IGltYWdlLndpZHRoXG4gICAgb2JqLmhlaWdodCA9IGltYWdlLmhlaWdodFxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpXG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0IsIGdsLlJHQiwgZ2wuVU5TSUdORURfQllURSwgaW1hZ2UpXG4gIH1cbiAgaW1hZ2Uuc3JjID0gdXJsXG5cbiAgcmV0dXJuIG9ialxufVxuXG5mdW5jdGlvbiB1cGRhdGVLZXl3b3JkcygpIHtcbiAgbGV0IGRpc3BsYXlLZXl3b3JkcyA9IFtdXG4gIGlmIChjb25maWcuU0hBRElORykgZGlzcGxheUtleXdvcmRzLnB1c2goJ1NIQURJTkcnKVxuICBpZiAoY29uZmlnLkJMT09NKSBkaXNwbGF5S2V5d29yZHMucHVzaCgnQkxPT00nKVxuICBpZiAoY29uZmlnLlNVTlJBWVMpIGRpc3BsYXlLZXl3b3Jkcy5wdXNoKCdTVU5SQVlTJylcbiAgZGlzcGxheU1hdGVyaWFsLnNldEtleXdvcmRzKGRpc3BsYXlLZXl3b3Jkcylcbn1cblxuLy8gTWFpblxudXBkYXRlS2V5d29yZHMoKVxuaW5pdEZyYW1lYnVmZmVycygpXG5tdWx0aXBsZVNwbGF0cyhzYWZlUGFyc2VJbnQoTWF0aC5yYW5kb20oKSAqIDIwKSArIDUpXG5cbmxldCBsYXN0VXBkYXRlVGltZSA9IERhdGUubm93KClcbmxldCBjb2xvclVwZGF0ZVRpbWVyID0gMC4wXG51cGRhdGUoKVxuXG5mdW5jdGlvbiB1cGRhdGUoKSB7XG4gIGNvbnN0IGR0ID0gY2FsY0RlbHRhVGltZSgpXG4gIGlmIChyZXNpemVDYW52YXMoKSkgaW5pdEZyYW1lYnVmZmVycygpXG4gIHVwZGF0ZUNvbG9ycyhkdClcbiAgYXBwbHlJbnB1dHMoKVxuICBpZiAoIWNvbmZpZy5QQVVTRUQpIHN0ZXAoZHQpXG4gIHJlbmRlcihudWxsKVxuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodXBkYXRlKVxufVxuXG5mdW5jdGlvbiBjYWxjRGVsdGFUaW1lKCkge1xuICBsZXQgbm93ID0gRGF0ZS5ub3coKVxuICBsZXQgZHQgPSAobm93IC0gbGFzdFVwZGF0ZVRpbWUpIC8gMTAwMFxuICBkdCA9IE1hdGgubWluKGR0LCAwLjAxNjY2NilcbiAgbGFzdFVwZGF0ZVRpbWUgPSBub3dcbiAgcmV0dXJuIGR0XG59XG5cbmZ1bmN0aW9uIHJlc2l6ZUNhbnZhcygpIHtcbiAgbGV0IHdpZHRoID0gc2NhbGVCeVBpeGVsUmF0aW8oY2FudmFzLmNsaWVudFdpZHRoKVxuICBsZXQgaGVpZ2h0ID0gc2NhbGVCeVBpeGVsUmF0aW8oY2FudmFzLmNsaWVudEhlaWdodClcbiAgaWYgKGNhbnZhcy53aWR0aCAhPSB3aWR0aCB8fCBjYW52YXMuaGVpZ2h0ICE9IGhlaWdodCkge1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoXG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodFxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbG9ycyhkdDogbnVtYmVyKSB7XG4gIGlmICghY29uZmlnLkNPTE9SRlVMKSByZXR1cm5cblxuICBjb2xvclVwZGF0ZVRpbWVyICs9IGR0ICogY29uZmlnLkNPTE9SX1VQREFURV9TUEVFRFxuICBpZiAoY29sb3JVcGRhdGVUaW1lciA+PSAxKSB7XG4gICAgY29sb3JVcGRhdGVUaW1lciA9IHdyYXAoY29sb3JVcGRhdGVUaW1lciwgMCwgMSlcbiAgICBwb2ludGVycy5mb3JFYWNoKHAgPT4ge1xuICAgICAgcC5jb2xvclVwZGF0ZXMrK1xuICAgICAgaWYgKHAuY29sb3JVcGRhdGVzID4gMikge1xuICAgICAgICBwLmNvbG9yID0gZ2VuZXJhdGVDb2xvcigpXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseUlucHV0cygpIHtcbiAgaWYgKHNwbGF0U3RhY2subGVuZ3RoID4gMCkgbXVsdGlwbGVTcGxhdHMoc3BsYXRTdGFjay5wb3AoKSB8fCAwKVxuXG4gIHBvaW50ZXJzLmZvckVhY2gocCA9PiB7XG4gICAgaWYgKHAubW92ZWQpIHtcbiAgICAgIHAubW92ZWQgPSBmYWxzZVxuICAgICAgc3BsYXRQb2ludGVyKHApXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBzdGVwKGR0OiBudW1iZXIpIHtcbiAgZ2wuZGlzYWJsZShnbC5CTEVORClcbiAgZ2wudmlld3BvcnQoMCwgMCwgdmVsb2NpdHkud2lkdGgsIHZlbG9jaXR5LmhlaWdodClcblxuICBjdXJsUHJvZ3JhbS5iaW5kKClcbiAgZ2wudW5pZm9ybTJmKGN1cmxQcm9ncmFtLnVuaWZvcm1zLnRleGVsU2l6ZSwgdmVsb2NpdHkudGV4ZWxTaXplWCwgdmVsb2NpdHkudGV4ZWxTaXplWSlcbiAgZ2wudW5pZm9ybTFpKGN1cmxQcm9ncmFtLnVuaWZvcm1zLnVWZWxvY2l0eSwgdmVsb2NpdHkucmVhZC5hdHRhY2goMCkpXG4gIGJsaXQoY3VybC5mYm8pXG5cbiAgdm9ydGljaXR5UHJvZ3JhbS5iaW5kKClcbiAgZ2wudW5pZm9ybTJmKHZvcnRpY2l0eVByb2dyYW0udW5pZm9ybXMudGV4ZWxTaXplLCB2ZWxvY2l0eS50ZXhlbFNpemVYLCB2ZWxvY2l0eS50ZXhlbFNpemVZKVxuICBnbC51bmlmb3JtMWkodm9ydGljaXR5UHJvZ3JhbS51bmlmb3Jtcy51VmVsb2NpdHksIHZlbG9jaXR5LnJlYWQuYXR0YWNoKDApKVxuICBnbC51bmlmb3JtMWkodm9ydGljaXR5UHJvZ3JhbS51bmlmb3Jtcy51Q3VybCwgY3VybC5hdHRhY2goMSkpXG4gIGdsLnVuaWZvcm0xZih2b3J0aWNpdHlQcm9ncmFtLnVuaWZvcm1zLmN1cmwsIGNvbmZpZy5DVVJMKVxuICBnbC51bmlmb3JtMWYodm9ydGljaXR5UHJvZ3JhbS51bmlmb3Jtcy5kdCwgZHQpXG4gIGJsaXQodmVsb2NpdHkud3JpdGUuZmJvKVxuICB2ZWxvY2l0eS5zd2FwKClcblxuICBkaXZlcmdlbmNlUHJvZ3JhbS5iaW5kKClcbiAgZ2wudW5pZm9ybTJmKGRpdmVyZ2VuY2VQcm9ncmFtLnVuaWZvcm1zLnRleGVsU2l6ZSwgdmVsb2NpdHkudGV4ZWxTaXplWCwgdmVsb2NpdHkudGV4ZWxTaXplWSlcbiAgZ2wudW5pZm9ybTFpKGRpdmVyZ2VuY2VQcm9ncmFtLnVuaWZvcm1zLnVWZWxvY2l0eSwgdmVsb2NpdHkucmVhZC5hdHRhY2goMCkpXG4gIGJsaXQoZGl2ZXJnZW5jZS5mYm8pXG5cbiAgY2xlYXJQcm9ncmFtLmJpbmQoKVxuICBnbC51bmlmb3JtMWkoY2xlYXJQcm9ncmFtLnVuaWZvcm1zLnVUZXh0dXJlLCBwcmVzc3VyZS5yZWFkLmF0dGFjaCgwKSlcbiAgZ2wudW5pZm9ybTFmKGNsZWFyUHJvZ3JhbS51bmlmb3Jtcy52YWx1ZSwgY29uZmlnLlBSRVNTVVJFKVxuICBibGl0KHByZXNzdXJlLndyaXRlLmZibylcbiAgcHJlc3N1cmUuc3dhcCgpXG5cbiAgcHJlc3N1cmVQcm9ncmFtLmJpbmQoKVxuICBnbC51bmlmb3JtMmYocHJlc3N1cmVQcm9ncmFtLnVuaWZvcm1zLnRleGVsU2l6ZSwgdmVsb2NpdHkudGV4ZWxTaXplWCwgdmVsb2NpdHkudGV4ZWxTaXplWSlcbiAgZ2wudW5pZm9ybTFpKHByZXNzdXJlUHJvZ3JhbS51bmlmb3Jtcy51RGl2ZXJnZW5jZSwgZGl2ZXJnZW5jZS5hdHRhY2goMCkpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29uZmlnLlBSRVNTVVJFX0lURVJBVElPTlM7IGkrKykge1xuICAgIGdsLnVuaWZvcm0xaShwcmVzc3VyZVByb2dyYW0udW5pZm9ybXMudVByZXNzdXJlLCBwcmVzc3VyZS5yZWFkLmF0dGFjaCgxKSlcbiAgICBibGl0KHByZXNzdXJlLndyaXRlLmZibylcbiAgICBwcmVzc3VyZS5zd2FwKClcbiAgfVxuXG4gIGdyYWRpZW5TdWJ0cmFjdFByb2dyYW0uYmluZCgpXG4gIGdsLnVuaWZvcm0yZihncmFkaWVuU3VidHJhY3RQcm9ncmFtLnVuaWZvcm1zLnRleGVsU2l6ZSwgdmVsb2NpdHkudGV4ZWxTaXplWCwgdmVsb2NpdHkudGV4ZWxTaXplWSlcbiAgZ2wudW5pZm9ybTFpKGdyYWRpZW5TdWJ0cmFjdFByb2dyYW0udW5pZm9ybXMudVByZXNzdXJlLCBwcmVzc3VyZS5yZWFkLmF0dGFjaCgwKSlcbiAgZ2wudW5pZm9ybTFpKGdyYWRpZW5TdWJ0cmFjdFByb2dyYW0udW5pZm9ybXMudVZlbG9jaXR5LCB2ZWxvY2l0eS5yZWFkLmF0dGFjaCgxKSlcbiAgYmxpdCh2ZWxvY2l0eS53cml0ZS5mYm8pXG4gIHZlbG9jaXR5LnN3YXAoKVxuXG4gIGFkdmVjdGlvblByb2dyYW0uYmluZCgpXG4gIGdsLnVuaWZvcm0yZihhZHZlY3Rpb25Qcm9ncmFtLnVuaWZvcm1zLnRleGVsU2l6ZSwgdmVsb2NpdHkudGV4ZWxTaXplWCwgdmVsb2NpdHkudGV4ZWxTaXplWSlcbiAgaWYgKCFleHQuc3VwcG9ydExpbmVhckZpbHRlcmluZylcbiAgICBnbC51bmlmb3JtMmYoYWR2ZWN0aW9uUHJvZ3JhbS51bmlmb3Jtcy5keWVUZXhlbFNpemUsIHZlbG9jaXR5LnRleGVsU2l6ZVgsIHZlbG9jaXR5LnRleGVsU2l6ZVkpXG4gIGxldCB2ZWxvY2l0eUlkID0gdmVsb2NpdHkucmVhZC5hdHRhY2goMClcbiAgZ2wudW5pZm9ybTFpKGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMudVZlbG9jaXR5LCB2ZWxvY2l0eUlkKVxuICBnbC51bmlmb3JtMWkoYWR2ZWN0aW9uUHJvZ3JhbS51bmlmb3Jtcy51U291cmNlLCB2ZWxvY2l0eUlkKVxuICBnbC51bmlmb3JtMWYoYWR2ZWN0aW9uUHJvZ3JhbS51bmlmb3Jtcy5kdCwgZHQpXG4gIGdsLnVuaWZvcm0xZihhZHZlY3Rpb25Qcm9ncmFtLnVuaWZvcm1zLmRpc3NpcGF0aW9uLCBjb25maWcuVkVMT0NJVFlfRElTU0lQQVRJT04pXG4gIGJsaXQodmVsb2NpdHkud3JpdGUuZmJvKVxuICB2ZWxvY2l0eS5zd2FwKClcblxuICBnbC52aWV3cG9ydCgwLCAwLCBkeWUud2lkdGgsIGR5ZS5oZWlnaHQpXG5cbiAgaWYgKCFleHQuc3VwcG9ydExpbmVhckZpbHRlcmluZylcbiAgICBnbC51bmlmb3JtMmYoYWR2ZWN0aW9uUHJvZ3JhbS51bmlmb3Jtcy5keWVUZXhlbFNpemUsIGR5ZS50ZXhlbFNpemVYLCBkeWUudGV4ZWxTaXplWSlcbiAgZ2wudW5pZm9ybTFpKGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMudVZlbG9jaXR5LCB2ZWxvY2l0eS5yZWFkLmF0dGFjaCgwKSlcbiAgZ2wudW5pZm9ybTFpKGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMudVNvdXJjZSwgZHllLnJlYWQuYXR0YWNoKDEpKVxuICBnbC51bmlmb3JtMWYoYWR2ZWN0aW9uUHJvZ3JhbS51bmlmb3Jtcy5kaXNzaXBhdGlvbiwgY29uZmlnLkRFTlNJVFlfRElTU0lQQVRJT04pXG4gIGJsaXQoZHllLndyaXRlLmZibylcbiAgZHllLnN3YXAoKVxufVxuXG5mdW5jdGlvbiByZW5kZXIodGFyZ2V0OiBGQk8gfCBudWxsKSB7XG4gIGlmIChjb25maWcuQkxPT00pIGFwcGx5Qmxvb20oZHllLnJlYWQsIGJsb29tKVxuICBpZiAoY29uZmlnLlNVTlJBWVMpIHtcbiAgICBhcHBseVN1bnJheXMoZHllLnJlYWQsIGR5ZS53cml0ZSwgc3VucmF5cylcbiAgICBibHVyRkJPKHN1bnJheXMsIHN1bnJheXNUZW1wLCAxKVxuICB9XG5cbiAgaWYgKHRhcmdldCA9PSBudWxsIHx8ICFjb25maWcuVFJBTlNQQVJFTlQpIHtcbiAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKVxuICAgIGdsLmVuYWJsZShnbC5CTEVORClcbiAgfSBlbHNlIHtcbiAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKVxuICB9XG5cbiAgbGV0IHdpZHRoID0gdGFyZ2V0ID09IG51bGwgPyBnbC5kcmF3aW5nQnVmZmVyV2lkdGggOiB0YXJnZXQud2lkdGhcbiAgbGV0IGhlaWdodCA9IHRhcmdldCA9PSBudWxsID8gZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCA6IHRhcmdldC5oZWlnaHRcbiAgZ2wudmlld3BvcnQoMCwgMCwgd2lkdGgsIGhlaWdodClcblxuICBsZXQgZmJvID0gdGFyZ2V0ID09IG51bGwgPyBudWxsIDogdGFyZ2V0LmZib1xuICBpZiAoIWNvbmZpZy5UUkFOU1BBUkVOVCkgZHJhd0NvbG9yKGZibywgbm9ybWFsaXplQ29sb3IoY29uZmlnLkJBQ0tfQ09MT1IpKVxuICBpZiAodGFyZ2V0ID09IG51bGwgJiYgY29uZmlnLlRSQU5TUEFSRU5UKSBkcmF3Q2hlY2tlcmJvYXJkKGZibylcbiAgZHJhd0Rpc3BsYXkoZmJvLCB3aWR0aCwgaGVpZ2h0KVxufVxuXG5mdW5jdGlvbiBkcmF3Q29sb3IoZmJvOiBXZWJHTEZyYW1lYnVmZmVyIHwgbnVsbCwgY29sb3I6IENvbG9yKSB7XG4gIGNvbG9yUHJvZ3JhbS5iaW5kKClcbiAgZ2wudW5pZm9ybTRmKGNvbG9yUHJvZ3JhbS51bmlmb3Jtcy5jb2xvciwgY29sb3IuciwgY29sb3IuZywgY29sb3IuYiwgMSlcbiAgYmxpdChmYm8pXG59XG5cbmZ1bmN0aW9uIGRyYXdDaGVja2VyYm9hcmQoZmJvOiBXZWJHTEZyYW1lYnVmZmVyIHwgbnVsbCkge1xuICBjaGVja2VyYm9hcmRQcm9ncmFtLmJpbmQoKVxuICBnbC51bmlmb3JtMWYoY2hlY2tlcmJvYXJkUHJvZ3JhbS51bmlmb3Jtcy5hc3BlY3RSYXRpbywgY2FudmFzLndpZHRoIC8gY2FudmFzLmhlaWdodClcbiAgYmxpdChmYm8pXG59XG5cbmZ1bmN0aW9uIGRyYXdEaXNwbGF5KGZibzogV2ViR0xGcmFtZWJ1ZmZlciB8IG51bGwsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKSB7XG4gIGRpc3BsYXlNYXRlcmlhbC5iaW5kKClcbiAgY29uc3QgdW5pZm9ybXMgPSBub3ROdWxsKGRpc3BsYXlNYXRlcmlhbC51bmlmb3JtcylcbiAgaWYgKGNvbmZpZy5TSEFESU5HKSBnbC51bmlmb3JtMmYodW5pZm9ybXMudGV4ZWxTaXplLCAxLjAgLyB3aWR0aCwgMS4wIC8gaGVpZ2h0KVxuICBnbC51bmlmb3JtMWkodW5pZm9ybXMudVRleHR1cmUsIGR5ZS5yZWFkLmF0dGFjaCgwKSlcbiAgaWYgKGNvbmZpZy5CTE9PTSkge1xuICAgIGdsLnVuaWZvcm0xaSh1bmlmb3Jtcy51Qmxvb20sIGJsb29tLmF0dGFjaCgxKSlcbiAgICBnbC51bmlmb3JtMWkodW5pZm9ybXMudURpdGhlcmluZywgZGl0aGVyaW5nVGV4dHVyZS5hdHRhY2goMikpXG4gICAgbGV0IHNjYWxlID0gZ2V0VGV4dHVyZVNjYWxlKGRpdGhlcmluZ1RleHR1cmUsIHdpZHRoLCBoZWlnaHQpXG4gICAgZ2wudW5pZm9ybTJmKHVuaWZvcm1zLmRpdGhlclNjYWxlLCBzY2FsZS54LCBzY2FsZS55KVxuICB9XG4gIGlmIChjb25maWcuU1VOUkFZUykgZ2wudW5pZm9ybTFpKHVuaWZvcm1zLnVTdW5yYXlzLCBzdW5yYXlzLmF0dGFjaCgzKSlcbiAgYmxpdChmYm8pXG59XG5cbmZ1bmN0aW9uIGFwcGx5Qmxvb20oc291cmNlOiBGQk8sIGRlc3RpbmF0aW9uOiBGQk8pIHtcbiAgaWYgKGJsb29tRnJhbWVidWZmZXJzLmxlbmd0aCA8IDIpIHJldHVyblxuXG4gIGxldCBsYXN0ID0gZGVzdGluYXRpb25cblxuICBnbC5kaXNhYmxlKGdsLkJMRU5EKVxuICBibG9vbVByZWZpbHRlclByb2dyYW0uYmluZCgpXG4gIGxldCBrbmVlID0gY29uZmlnLkJMT09NX1RIUkVTSE9MRCAqIGNvbmZpZy5CTE9PTV9TT0ZUX0tORUUgKyAwLjAwMDFcbiAgbGV0IGN1cnZlMCA9IGNvbmZpZy5CTE9PTV9USFJFU0hPTEQgLSBrbmVlXG4gIGxldCBjdXJ2ZTEgPSBrbmVlICogMlxuICBsZXQgY3VydmUyID0gMC4yNSAvIGtuZWVcbiAgZ2wudW5pZm9ybTNmKGJsb29tUHJlZmlsdGVyUHJvZ3JhbS51bmlmb3Jtcy5jdXJ2ZSwgY3VydmUwLCBjdXJ2ZTEsIGN1cnZlMilcbiAgZ2wudW5pZm9ybTFmKGJsb29tUHJlZmlsdGVyUHJvZ3JhbS51bmlmb3Jtcy50aHJlc2hvbGQsIGNvbmZpZy5CTE9PTV9USFJFU0hPTEQpXG4gIGdsLnVuaWZvcm0xaShibG9vbVByZWZpbHRlclByb2dyYW0udW5pZm9ybXMudVRleHR1cmUsIHNvdXJjZS5hdHRhY2goMCkpXG4gIGdsLnZpZXdwb3J0KDAsIDAsIGxhc3Qud2lkdGgsIGxhc3QuaGVpZ2h0KVxuICBibGl0KGxhc3QuZmJvKVxuXG4gIGJsb29tQmx1clByb2dyYW0uYmluZCgpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvb21GcmFtZWJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgZGVzdCA9IGJsb29tRnJhbWVidWZmZXJzW2ldXG4gICAgZ2wudW5pZm9ybTJmKGJsb29tQmx1clByb2dyYW0udW5pZm9ybXMudGV4ZWxTaXplLCBsYXN0LnRleGVsU2l6ZVgsIGxhc3QudGV4ZWxTaXplWSlcbiAgICBnbC51bmlmb3JtMWkoYmxvb21CbHVyUHJvZ3JhbS51bmlmb3Jtcy51VGV4dHVyZSwgbGFzdC5hdHRhY2goMCkpXG4gICAgZ2wudmlld3BvcnQoMCwgMCwgZGVzdC53aWR0aCwgZGVzdC5oZWlnaHQpXG4gICAgYmxpdChkZXN0LmZibylcbiAgICBsYXN0ID0gZGVzdFxuICB9XG5cbiAgZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FKVxuICBnbC5lbmFibGUoZ2wuQkxFTkQpXG5cbiAgZm9yIChsZXQgaSA9IGJsb29tRnJhbWVidWZmZXJzLmxlbmd0aCAtIDI7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGV0IGJhc2VUZXggPSBibG9vbUZyYW1lYnVmZmVyc1tpXVxuICAgIGdsLnVuaWZvcm0yZihibG9vbUJsdXJQcm9ncmFtLnVuaWZvcm1zLnRleGVsU2l6ZSwgbGFzdC50ZXhlbFNpemVYLCBsYXN0LnRleGVsU2l6ZVkpXG4gICAgZ2wudW5pZm9ybTFpKGJsb29tQmx1clByb2dyYW0udW5pZm9ybXMudVRleHR1cmUsIGxhc3QuYXR0YWNoKDApKVxuICAgIGdsLnZpZXdwb3J0KDAsIDAsIGJhc2VUZXgud2lkdGgsIGJhc2VUZXguaGVpZ2h0KVxuICAgIGJsaXQoYmFzZVRleC5mYm8pXG4gICAgbGFzdCA9IGJhc2VUZXhcbiAgfVxuXG4gIGdsLmRpc2FibGUoZ2wuQkxFTkQpXG4gIGJsb29tRmluYWxQcm9ncmFtLmJpbmQoKVxuICBnbC51bmlmb3JtMmYoYmxvb21GaW5hbFByb2dyYW0udW5pZm9ybXMudGV4ZWxTaXplLCBsYXN0LnRleGVsU2l6ZVgsIGxhc3QudGV4ZWxTaXplWSlcbiAgZ2wudW5pZm9ybTFpKGJsb29tRmluYWxQcm9ncmFtLnVuaWZvcm1zLnVUZXh0dXJlLCBsYXN0LmF0dGFjaCgwKSlcbiAgZ2wudW5pZm9ybTFmKGJsb29tRmluYWxQcm9ncmFtLnVuaWZvcm1zLmludGVuc2l0eSwgY29uZmlnLkJMT09NX0lOVEVOU0lUWSlcbiAgZ2wudmlld3BvcnQoMCwgMCwgZGVzdGluYXRpb24ud2lkdGgsIGRlc3RpbmF0aW9uLmhlaWdodClcbiAgYmxpdChkZXN0aW5hdGlvbi5mYm8pXG59XG5cbmZ1bmN0aW9uIGFwcGx5U3VucmF5cyhzb3VyY2U6IEZCTywgbWFzazogRkJPLCBkZXN0aW5hdGlvbjogRkJPKSB7XG4gIGdsLmRpc2FibGUoZ2wuQkxFTkQpXG4gIHN1bnJheXNNYXNrUHJvZ3JhbS5iaW5kKClcbiAgZ2wudW5pZm9ybTFpKHN1bnJheXNNYXNrUHJvZ3JhbS51bmlmb3Jtcy51VGV4dHVyZSwgc291cmNlLmF0dGFjaCgwKSlcbiAgZ2wudmlld3BvcnQoMCwgMCwgbWFzay53aWR0aCwgbWFzay5oZWlnaHQpXG4gIGJsaXQobWFzay5mYm8pXG5cbiAgc3VucmF5c1Byb2dyYW0uYmluZCgpXG4gIGdsLnVuaWZvcm0xZihzdW5yYXlzUHJvZ3JhbS51bmlmb3Jtcy53ZWlnaHQsIGNvbmZpZy5TVU5SQVlTX1dFSUdIVClcbiAgZ2wudW5pZm9ybTFpKHN1bnJheXNQcm9ncmFtLnVuaWZvcm1zLnVUZXh0dXJlLCBtYXNrLmF0dGFjaCgwKSlcbiAgZ2wudmlld3BvcnQoMCwgMCwgZGVzdGluYXRpb24ud2lkdGgsIGRlc3RpbmF0aW9uLmhlaWdodClcbiAgYmxpdChkZXN0aW5hdGlvbi5mYm8pXG59XG5cbmZ1bmN0aW9uIGJsdXJGQk8odGFyZ2V0OiBGQk8sIHRlbXA6IEZCTywgaXRlcmF0aW9uczogbnVtYmVyKSB7XG4gIGJsdXJQcm9ncmFtLmJpbmQoKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuICAgIGdsLnVuaWZvcm0yZihibHVyUHJvZ3JhbS51bmlmb3Jtcy50ZXhlbFNpemUsIHRhcmdldC50ZXhlbFNpemVYLCAwLjApXG4gICAgZ2wudW5pZm9ybTFpKGJsdXJQcm9ncmFtLnVuaWZvcm1zLnVUZXh0dXJlLCB0YXJnZXQuYXR0YWNoKDApKVxuICAgIGJsaXQodGVtcC5mYm8pXG5cbiAgICBnbC51bmlmb3JtMmYoYmx1clByb2dyYW0udW5pZm9ybXMudGV4ZWxTaXplLCAwLjAsIHRhcmdldC50ZXhlbFNpemVZKVxuICAgIGdsLnVuaWZvcm0xaShibHVyUHJvZ3JhbS51bmlmb3Jtcy51VGV4dHVyZSwgdGVtcC5hdHRhY2goMCkpXG4gICAgYmxpdCh0YXJnZXQuZmJvKVxuICB9XG59XG5cbmZ1bmN0aW9uIHNwbGF0UG9pbnRlcihwb2ludGVyOiBQb2ludGVyKSB7XG4gIGxldCBkeCA9IHBvaW50ZXIuZGVsdGFYICogY29uZmlnLlNQTEFUX0ZPUkNFXG4gIGxldCBkeSA9IHBvaW50ZXIuZGVsdGFZICogY29uZmlnLlNQTEFUX0ZPUkNFXG4gIHNwbGF0KHBvaW50ZXIudGV4Y29vcmRYLCBwb2ludGVyLnRleGNvb3JkWSwgZHgsIGR5LCBwb2ludGVyLmNvbG9yKVxufVxuXG5mdW5jdGlvbiBtdWx0aXBsZVNwbGF0cyhhbW91bnQ6IG51bWJlcikge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSB7XG4gICAgY29uc3QgY29sb3IgPSBnZW5lcmF0ZUNvbG9yKClcbiAgICBjb2xvci5yICo9IDEwLjBcbiAgICBjb2xvci5nICo9IDEwLjBcbiAgICBjb2xvci5iICo9IDEwLjBcbiAgICBjb25zdCB4ID0gTWF0aC5yYW5kb20oKVxuICAgIGNvbnN0IHkgPSBNYXRoLnJhbmRvbSgpXG4gICAgY29uc3QgZHggPSAxMDAwICogKE1hdGgucmFuZG9tKCkgLSAwLjUpXG4gICAgY29uc3QgZHkgPSAxMDAwICogKE1hdGgucmFuZG9tKCkgLSAwLjUpXG4gICAgc3BsYXQoeCwgeSwgZHgsIGR5LCBjb2xvcilcbiAgfVxufVxuXG4vKipcbiAqIFNwbGF0IHNvbWUgZHllIGludG8gdGhlIHNpbXVsYXRpb24uXG4gKiBAcGFyYW0geCBDZW50ZXIgWCBjb29yZGluYXRlLiBGbG9hdCBmcm9tIDAgKGxlZnQpIHRvIDEgKHJpZ2h0KVxuICogQHBhcmFtIHkgQ2VudGVyIFkgY29vcmRpbmF0ZS4gRmxvYXQgZm9ybSAwIChib3R0b20pIHRvIDEgKHRvcClcbiAqIEBwYXJhbSBkeCBIb3Jpem9udGFsIGZvcmNlIHZlY3RvciBlbGVtZW50LCBpbiBwaXhlbHMuIFBvc2l0aXZlIC0+IGxlZnQsIG5lZ2F0aXZlIC0+IHJpZ2h0LlxuICogQHBhcmFtIGR5IFZlcnRpY2FsIGZvcmNlIHZlY3RvciBlbGVtZW50LCBpbiBwaXhlbHMuIFBvc2l0aXZlIC0+IHRvcCwgbmVnYXRpdmUgLT4gYm90dG9tLlxuICogQHBhcmFtIGNvbG9yIENvbG9yLiBVc2luZyB7IHIsIGcsIGIgfSB2YWx1ZXMgPjEgY3JlYXRlcyBhIGxhcmdlciBzcGxhdC5cbiAqL1xuZnVuY3Rpb24gc3BsYXQoeDogbnVtYmVyLCB5OiBudW1iZXIsIGR4OiBudW1iZXIsIGR5OiBudW1iZXIsIGNvbG9yPzogQ29sb3IsIHJhZGl1cz86IG51bWJlcikge1xuICBnbC52aWV3cG9ydCgwLCAwLCB2ZWxvY2l0eS53aWR0aCwgdmVsb2NpdHkuaGVpZ2h0KVxuICBzcGxhdFByb2dyYW0uYmluZCgpXG4gIGdsLnVuaWZvcm0xaShzcGxhdFByb2dyYW0udW5pZm9ybXMudVRhcmdldCwgdmVsb2NpdHkucmVhZC5hdHRhY2goMCkpXG4gIGdsLnVuaWZvcm0xZihzcGxhdFByb2dyYW0udW5pZm9ybXMuYXNwZWN0UmF0aW8sIGNhbnZhcy53aWR0aCAvIGNhbnZhcy5oZWlnaHQpXG4gIGdsLnVuaWZvcm0yZihzcGxhdFByb2dyYW0udW5pZm9ybXMucG9pbnQsIHgsIHkpXG4gIGdsLnVuaWZvcm0zZihzcGxhdFByb2dyYW0udW5pZm9ybXMuY29sb3IsIGR4LCBkeSwgMC4wKVxuICBnbC51bmlmb3JtMWYoc3BsYXRQcm9ncmFtLnVuaWZvcm1zLnJhZGl1cywgY29ycmVjdFJhZGl1cygocmFkaXVzIHx8IGNvbmZpZy5TUExBVF9SQURJVVMpIC8gMTAwLjApKVxuICBibGl0KHZlbG9jaXR5LndyaXRlLmZibylcbiAgdmVsb2NpdHkuc3dhcCgpXG5cbiAgaWYgKGNvbG9yKSB7XG4gICAgZ2wudmlld3BvcnQoMCwgMCwgZHllLndpZHRoLCBkeWUuaGVpZ2h0KVxuICAgIGdsLnVuaWZvcm0xaShzcGxhdFByb2dyYW0udW5pZm9ybXMudVRhcmdldCwgZHllLnJlYWQuYXR0YWNoKDApKVxuICAgIGdsLnVuaWZvcm0zZihzcGxhdFByb2dyYW0udW5pZm9ybXMuY29sb3IsIGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIpXG4gICAgYmxpdChkeWUud3JpdGUuZmJvKVxuICAgIGR5ZS5zd2FwKClcbiAgfVxufVxuXG5mdW5jdGlvbiBjb3JyZWN0UmFkaXVzKHJhZGl1czogbnVtYmVyKSB7XG4gIGxldCBhc3BlY3RSYXRpbyA9IGNhbnZhcy53aWR0aCAvIGNhbnZhcy5oZWlnaHRcbiAgaWYgKGFzcGVjdFJhdGlvID4gMSkgcmFkaXVzICo9IGFzcGVjdFJhdGlvXG4gIHJldHVybiByYWRpdXNcbn1cblxuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGUgPT4ge1xuICBsZXQgcG9zWCA9IHNjYWxlQnlQaXhlbFJhdGlvKGUub2Zmc2V0WClcbiAgbGV0IHBvc1kgPSBzY2FsZUJ5UGl4ZWxSYXRpbyhlLm9mZnNldFkpXG4gIGxldCBwb2ludGVyID0gcG9pbnRlcnMuZmluZChwID0+IHAuaWQgPT0gLTEpXG4gIGlmIChwb2ludGVyID09IG51bGwpIHBvaW50ZXIgPSBuZXcgUG9pbnRlcigpXG4gIHVwZGF0ZVBvaW50ZXJEb3duRGF0YShwb2ludGVyLCAtMSwgcG9zWCwgcG9zWSlcbn0pXG5cbmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBlID0+IHtcbiAgbGV0IHBvaW50ZXIgPSBwb2ludGVyc1swXVxuICBpZiAoIXBvaW50ZXIuZG93bikgcmV0dXJuXG4gIGxldCBwb3NYID0gc2NhbGVCeVBpeGVsUmF0aW8oZS5vZmZzZXRYKVxuICBsZXQgcG9zWSA9IHNjYWxlQnlQaXhlbFJhdGlvKGUub2Zmc2V0WSlcbiAgdXBkYXRlUG9pbnRlck1vdmVEYXRhKHBvaW50ZXIsIHBvc1gsIHBvc1kpXG59KVxuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsICgpID0+IHtcbiAgdXBkYXRlUG9pbnRlclVwRGF0YShwb2ludGVyc1swXSlcbn0pXG5cbmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgZSA9PiB7XG4gIGUucHJldmVudERlZmF1bHQoKVxuICBjb25zdCB0b3VjaGVzID0gZS50YXJnZXRUb3VjaGVzXG4gIHdoaWxlICh0b3VjaGVzLmxlbmd0aCA+PSBwb2ludGVycy5sZW5ndGgpIHBvaW50ZXJzLnB1c2gobmV3IFBvaW50ZXIoKSlcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IHBvc1ggPSBzY2FsZUJ5UGl4ZWxSYXRpbyh0b3VjaGVzW2ldLnBhZ2VYKVxuICAgIGxldCBwb3NZID0gc2NhbGVCeVBpeGVsUmF0aW8odG91Y2hlc1tpXS5wYWdlWSlcbiAgICB1cGRhdGVQb2ludGVyRG93bkRhdGEocG9pbnRlcnNbaSArIDFdLCB0b3VjaGVzW2ldLmlkZW50aWZpZXIsIHBvc1gsIHBvc1kpXG4gIH1cbn0pXG5cbmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFxuICAndG91Y2htb3ZlJyxcbiAgZSA9PiB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgY29uc3QgdG91Y2hlcyA9IGUudGFyZ2V0VG91Y2hlc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHBvaW50ZXIgPSBwb2ludGVyc1tpICsgMV1cbiAgICAgIGlmICghcG9pbnRlci5kb3duKSBjb250aW51ZVxuICAgICAgbGV0IHBvc1ggPSBzY2FsZUJ5UGl4ZWxSYXRpbyh0b3VjaGVzW2ldLnBhZ2VYKVxuICAgICAgbGV0IHBvc1kgPSBzY2FsZUJ5UGl4ZWxSYXRpbyh0b3VjaGVzW2ldLnBhZ2VZKVxuICAgICAgdXBkYXRlUG9pbnRlck1vdmVEYXRhKHBvaW50ZXIsIHBvc1gsIHBvc1kpXG4gICAgfVxuICB9LFxuICBmYWxzZVxuKVxuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBlID0+IHtcbiAgY29uc3QgdG91Y2hlcyA9IGUuY2hhbmdlZFRvdWNoZXNcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IHBvaW50ZXIgPSBwb2ludGVycy5maW5kKHAgPT4gcC5pZCA9PSB0b3VjaGVzW2ldLmlkZW50aWZpZXIpXG4gICAgaWYgKHBvaW50ZXIgPT0gbnVsbCkgY29udGludWVcbiAgICB1cGRhdGVQb2ludGVyVXBEYXRhKHBvaW50ZXIpXG4gIH1cbn0pXG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZSA9PiB7XG4gIGlmIChlLmNvZGUgPT09ICdLZXlQJykgY29uZmlnLlBBVVNFRCA9ICFjb25maWcuUEFVU0VEXG4gIGlmIChlLmtleSA9PT0gJyAnKSBzcGxhdFN0YWNrLnB1c2goc2FmZVBhcnNlSW50KE1hdGgucmFuZG9tKCkgKiAyMCkgKyA1KVxufSlcblxuZnVuY3Rpb24gdXBkYXRlUG9pbnRlckRvd25EYXRhKHBvaW50ZXI6IFBvaW50ZXIsIGlkOiBudW1iZXIsIHBvc1g6IG51bWJlciwgcG9zWTogbnVtYmVyKSB7XG4gIHBvaW50ZXIuaWQgPSBpZFxuICBwb2ludGVyLmRvd24gPSB0cnVlXG4gIHBvaW50ZXIubW92ZWQgPSBmYWxzZVxuICBwb2ludGVyLnRleGNvb3JkWCA9IHBvc1ggLyBjYW52YXMud2lkdGhcbiAgcG9pbnRlci50ZXhjb29yZFkgPSAxLjAgLSBwb3NZIC8gY2FudmFzLmhlaWdodFxuICBwb2ludGVyLnByZXZUZXhjb29yZFggPSBwb2ludGVyLnRleGNvb3JkWFxuICBwb2ludGVyLnByZXZUZXhjb29yZFkgPSBwb2ludGVyLnRleGNvb3JkWVxuICBwb2ludGVyLmRlbHRhWCA9IDBcbiAgcG9pbnRlci5kZWx0YVkgPSAwXG4gIHBvaW50ZXIuY29sb3JVcGRhdGVzID0gMFxuXG4gIGlmICghY29uZmlnLlJBTkRPTV9DT0xPUikge1xuICAgIHBvaW50ZXIuY29sb3IgPSBtdXRlVUlDb2xvcihjb25maWcuU1BMQVRfQ09MT1IpXG4gIH0gZWxzZSB7XG4gICAgcG9pbnRlci5jb2xvciA9IGdlbmVyYXRlQ29sb3IoKVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVBvaW50ZXJNb3ZlRGF0YShwb2ludGVyOiBQb2ludGVyLCBwb3NYOiBudW1iZXIsIHBvc1k6IG51bWJlcikge1xuICBwb2ludGVyLnByZXZUZXhjb29yZFggPSBwb2ludGVyLnRleGNvb3JkWFxuICBwb2ludGVyLnByZXZUZXhjb29yZFkgPSBwb2ludGVyLnRleGNvb3JkWVxuICBwb2ludGVyLnRleGNvb3JkWCA9IHBvc1ggLyBjYW52YXMud2lkdGhcbiAgcG9pbnRlci50ZXhjb29yZFkgPSAxLjAgLSBwb3NZIC8gY2FudmFzLmhlaWdodFxuICBwb2ludGVyLmRlbHRhWCA9IGNvcnJlY3REZWx0YVgocG9pbnRlci50ZXhjb29yZFggLSBwb2ludGVyLnByZXZUZXhjb29yZFgpXG4gIHBvaW50ZXIuZGVsdGFZID0gY29ycmVjdERlbHRhWShwb2ludGVyLnRleGNvb3JkWSAtIHBvaW50ZXIucHJldlRleGNvb3JkWSlcbiAgcG9pbnRlci5tb3ZlZCA9IE1hdGguYWJzKHBvaW50ZXIuZGVsdGFYKSA+IDAgfHwgTWF0aC5hYnMocG9pbnRlci5kZWx0YVkpID4gMFxufVxuXG5mdW5jdGlvbiB1cGRhdGVQb2ludGVyVXBEYXRhKHBvaW50ZXI6IFBvaW50ZXIpIHtcbiAgcG9pbnRlci5kb3duID0gZmFsc2Vcbn1cblxuZnVuY3Rpb24gY29ycmVjdERlbHRhWChkZWx0YTogbnVtYmVyKSB7XG4gIGxldCBhc3BlY3RSYXRpbyA9IGNhbnZhcy53aWR0aCAvIGNhbnZhcy5oZWlnaHRcbiAgaWYgKGFzcGVjdFJhdGlvIDwgMSkgZGVsdGEgKj0gYXNwZWN0UmF0aW9cbiAgcmV0dXJuIGRlbHRhXG59XG5cbmZ1bmN0aW9uIGNvcnJlY3REZWx0YVkoZGVsdGE6IG51bWJlcikge1xuICBsZXQgYXNwZWN0UmF0aW8gPSBjYW52YXMud2lkdGggLyBjYW52YXMuaGVpZ2h0XG4gIGlmIChhc3BlY3RSYXRpbyA+IDEpIGRlbHRhIC89IGFzcGVjdFJhdGlvXG4gIHJldHVybiBkZWx0YVxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUNvbG9yKCkge1xuICBsZXQgYyA9IEhTVnRvUkdCKE1hdGgucmFuZG9tKCksIDEuMCwgMS4wKVxuICBjLnIgKj0gMC4xNVxuICBjLmcgKj0gMC4xNVxuICBjLmIgKj0gMC4xNVxuICByZXR1cm4gY1xufVxuXG5mdW5jdGlvbiBIU1Z0b1JHQihoOiBudW1iZXIsIHM6IG51bWJlciwgdjogbnVtYmVyKSB7XG4gIGxldCByID0gMCxcbiAgICBnID0gMCxcbiAgICBiID0gMCxcbiAgICBpID0gMCxcbiAgICBmID0gMCxcbiAgICBwID0gMCxcbiAgICBxID0gMCxcbiAgICB0ID0gMFxuICBpID0gTWF0aC5mbG9vcihoICogNilcbiAgZiA9IGggKiA2IC0gaVxuICBwID0gdiAqICgxIC0gcylcbiAgcSA9IHYgKiAoMSAtIGYgKiBzKVxuICB0ID0gdiAqICgxIC0gKDEgLSBmKSAqIHMpXG5cbiAgc3dpdGNoIChpICUgNikge1xuICAgIGNhc2UgMDpcbiAgICAgIDsociA9IHYpLCAoZyA9IHQpLCAoYiA9IHApXG4gICAgICBicmVha1xuICAgIGNhc2UgMTpcbiAgICAgIDsociA9IHEpLCAoZyA9IHYpLCAoYiA9IHApXG4gICAgICBicmVha1xuICAgIGNhc2UgMjpcbiAgICAgIDsociA9IHApLCAoZyA9IHYpLCAoYiA9IHQpXG4gICAgICBicmVha1xuICAgIGNhc2UgMzpcbiAgICAgIDsociA9IHApLCAoZyA9IHEpLCAoYiA9IHYpXG4gICAgICBicmVha1xuICAgIGNhc2UgNDpcbiAgICAgIDsociA9IHQpLCAoZyA9IHApLCAoYiA9IHYpXG4gICAgICBicmVha1xuICAgIGNhc2UgNTpcbiAgICAgIDsociA9IHYpLCAoZyA9IHApLCAoYiA9IHEpXG4gICAgICBicmVha1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByLFxuICAgIGcsXG4gICAgYixcbiAgfVxufVxuXG50eXBlIENvbG9yID0geyByOiBudW1iZXI7IGc6IG51bWJlcjsgYjogbnVtYmVyIH1cblxuZnVuY3Rpb24gbm9ybWFsaXplQ29sb3IoaW5wdXQ6IENvbG9yKTogQ29sb3Ige1xuICBsZXQgb3V0cHV0ID0ge1xuICAgIHI6IGlucHV0LnIgLyAyNTUsXG4gICAgZzogaW5wdXQuZyAvIDI1NSxcbiAgICBiOiBpbnB1dC5iIC8gMjU1LFxuICB9XG4gIHJldHVybiBvdXRwdXRcbn1cblxuZnVuY3Rpb24gdGZDb2xvcihpbnB1dDogQ29sb3IsIHRmOiAoeDogbnVtYmVyKSA9PiBudW1iZXIpOiBDb2xvciB7XG4gIGxldCBvdXRwdXQgPSB7XG4gICAgcjogdGYoaW5wdXQuciksXG4gICAgZzogdGYoaW5wdXQuZyksXG4gICAgYjogdGYoaW5wdXQuYiksXG4gIH1cbiAgcmV0dXJuIG91dHB1dFxufVxuXG5jb25zdCBtdXRlVUlDb2xvciA9IChjb2xvcjogQ29sb3IpID0+IHRmQ29sb3IoY29sb3IsIHggPT4geCAvIDI3MCArIDAuMDUpXG5cbmZ1bmN0aW9uIHdyYXAodmFsdWU6IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKSB7XG4gIGxldCByYW5nZSA9IG1heCAtIG1pblxuICBpZiAocmFuZ2UgPT0gMCkgcmV0dXJuIG1pblxuICByZXR1cm4gKCh2YWx1ZSAtIG1pbikgJSByYW5nZSkgKyBtaW5cbn1cblxuZnVuY3Rpb24gZ2V0UmVzb2x1dGlvbihyZXNvbHV0aW9uOiBudW1iZXIpIHtcbiAgbGV0IGFzcGVjdFJhdGlvID0gZ2wuZHJhd2luZ0J1ZmZlcldpZHRoIC8gZ2wuZHJhd2luZ0J1ZmZlckhlaWdodFxuICBpZiAoYXNwZWN0UmF0aW8gPCAxKSBhc3BlY3RSYXRpbyA9IDEuMCAvIGFzcGVjdFJhdGlvXG5cbiAgbGV0IG1pbiA9IE1hdGgucm91bmQocmVzb2x1dGlvbilcbiAgbGV0IG1heCA9IE1hdGgucm91bmQocmVzb2x1dGlvbiAqIGFzcGVjdFJhdGlvKVxuXG4gIGlmIChnbC5kcmF3aW5nQnVmZmVyV2lkdGggPiBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0KSByZXR1cm4geyB3aWR0aDogbWF4LCBoZWlnaHQ6IG1pbiB9XG4gIGVsc2UgcmV0dXJuIHsgd2lkdGg6IG1pbiwgaGVpZ2h0OiBtYXggfVxufVxuXG5mdW5jdGlvbiBnZXRUZXh0dXJlU2NhbGUodGV4dHVyZTogVGV4dHVyZSwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiB3aWR0aCAvIHRleHR1cmUud2lkdGgsXG4gICAgeTogaGVpZ2h0IC8gdGV4dHVyZS5oZWlnaHQsXG4gIH1cbn1cblxuZnVuY3Rpb24gc2NhbGVCeVBpeGVsUmF0aW8oaW5wdXQ6IG51bWJlcikge1xuICBsZXQgcGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDFcbiAgcmV0dXJuIE1hdGguZmxvb3IoaW5wdXQgKiBwaXhlbFJhdGlvKVxufVxuXG5mdW5jdGlvbiBoYXNoQ29kZShzOiBzdHJpbmcpIHtcbiAgaWYgKHMubGVuZ3RoID09IDApIHJldHVybiAwXG4gIGxldCBoYXNoID0gMFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIHtcbiAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgcy5jaGFyQ29kZUF0KGkpXG4gICAgaGFzaCB8PSAwIC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICB9XG4gIHJldHVybiBoYXNoXG59XG4iXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkE7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQVFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFBQTtBQUFBO0FBSEE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUJBO0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkE7QUFHQTs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBR0E7Ozs7Ozs7Ozs7QUFZQTtBQUdBOzs7Ozs7Ozs7OztBQWFBO0FBR0E7Ozs7Ozs7O0FBVUE7QUFHQTs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQTtBQUdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUErREE7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkE7QUFHQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCQTtBQUdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCQTtBQUdBOzs7Ozs7Ozs7Ozs7O0FBZUE7QUFHQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUNBO0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQTtBQUdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQ0E7QUFJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0QkE7QUFHQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCQTtBQUdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStCQTtBQUdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0JBO0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVCQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBU0E7QUFVQTtBQUNBOztBQVNBO0FBVUE7QUFRQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFRQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQVNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBRUE7QUFBQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./script.ts\n");

/***/ })

/******/ });